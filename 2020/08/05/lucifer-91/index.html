<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <title>leetcode | Rock-Blog</title>
  <meta name="keywords" content=" 数学 , 编程 , python ">
  <meta name="description" content="leetcode | Rock-Blog">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="2020-09-25智能对抗初赛后的停顿与反思，全文主要 https://mp.weixin.qq.com/s/FFb1HZOQn48V-L7IhFgRGQ 或者 https://zhuanlan.zhihu.com/p/39999667 DRL近三年的应用成果分类 棋牌类游戏（麻将、德克萨斯等游戏）、Atari游戏、星际争霸达到专业玩家水平甚至超人类水平-deepmind  控制机械臂-open">
<meta name="keywords" content="数学,深度学习,强化学习">
<meta property="og:type" content="article">
<meta property="og:title" content="DRL_report">
<meta property="og:url" content="http://rock-blog.top/20120/09/25/DRL-report/index.html">
<meta property="og:site_name" content="Rock-Blog">
<meta property="og:description" content="2020-09-25智能对抗初赛后的停顿与反思，全文主要 https://mp.weixin.qq.com/s/FFb1HZOQn48V-L7IhFgRGQ 或者 https://zhuanlan.zhihu.com/p/39999667 DRL近三年的应用成果分类 棋牌类游戏（麻将、德克萨斯等游戏）、Atari游戏、星际争霸达到专业玩家水平甚至超人类水平-deepmind  控制机械臂-open">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://rock-blog.top/20120/09/25/DRL-report/D:/rockblog/source/rockblog/source/_posts/DRL-report/1.jpg">
<meta property="og:updated_time" content="2020-09-26T13:30:39.729Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DRL_report">
<meta name="twitter:description" content="2020-09-25智能对抗初赛后的停顿与反思，全文主要 https://mp.weixin.qq.com/s/FFb1HZOQn48V-L7IhFgRGQ 或者 https://zhuanlan.zhihu.com/p/39999667 DRL近三年的应用成果分类 棋牌类游戏（麻将、德克萨斯等游戏）、Atari游戏、星际争霸达到专业玩家水平甚至超人类水平-deepmind  控制机械臂-open">
<meta name="twitter:image" content="http://rock-blog.top/20120/09/25/DRL-report/D:/rockblog/source/rockblog/source/_posts/DRL-report/1.jpg">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.0.1" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.0.1" rel="stylesheet">

<link href="//cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet">
<link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="/js/jquery.autocomplete.min.js?v=1.0.1"></script>

<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>



<script src="//cdn.bootcss.com/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>

<script src="/js/iconfont.js?v=1.0.1"></script>

</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="true">
  <input class="theme_blog_path" value>
</div>

<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="/img/avatar.jpg">
</a>
<div class="author">
    <span>Rock</span>
</div>

<div class="icon">
    
        
        <a title="github" href="https://github.com/guobaoyo" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-github"/>
                </svg>
            
        </a>
        
    
        
        <a title="email" href="mailto:1415500736@qq.com" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-email"/>
                </svg>
            
        </a>
        
    
        
        <a title="qq" href="http://wpa.qq.com/msgrd?v=3&uin=1415500736&site=qq&menu=yes" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-qq"/>
                </svg>
            
        </a>
        
    
        
        <a title="neteasemusic" href="https://music.163.com/#/user/home?id=280020740" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-neteasemusic"/>
                </svg>
            
        </a>
        
    
</div>




<ul>
    <li><div class="all active">全部文章<small>(49)</small></div></li>
    
        
            
            <li><div data-rel="三省吾身">三省吾身<small>(5)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="强化学习">强化学习<small>(16)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="AI">AI<small>(7)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="编程">编程<small>(17)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="数学">数学<small>(2)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="组会报告">组会报告<small>(1)</small></div>
                
            </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    
    
    </div>
    <div><a class="friends">友链</a></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="49">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="back-title-list"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
            <li><a target="_blank" href="http://zivblog.top">王金锋</a></li>
            
            <li><a target="_blank" href="http://yearing1017.cn/">进哥</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <form onkeydown="if(event.keyCode==13){return false;}">
        <input class="search" type="text" placeholder="以 in: 开头进行全文搜索" autocomplete="off" id="local-search-input">
        <i class="cross"></i>
        <span>
            <label for="tagswitch">Tags:</label>
            <input id="tagswitch" type="checkbox" style="display: none">
            <i id="tagsWitchIcon"></i>
        </span>
    </form>
    <div class="tags-list">
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">三省吾身</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">AI</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">数学</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">编程</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">深度学习</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">CV</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">python</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">强化学习</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">技术小节</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">go</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">技术小结</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">leetcode</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">组会报告</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">考研</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">NLP</a>
    </li>
    
    <div class="clearfix"></div>
</div>

    
    <div id="local-search-result">

    </div>
    
    <nav id="title-list-nav">
        
        <a class="三省吾身 " href="/2019/07/08/20190708日记/" data-tag="三省吾身,AI,数学" data-author>
            <span class="post-title" title="20190708日记">20190708日记</span>
            <span class="post-date" title="2019-07-08 19:43:26">2019/07/08</span>
        </a>
        
        <a class="强化学习 " href="/2020/06/08/A-algorithm/" data-tag="AI,数学,编程" data-author>
            <span class="post-title" title="A*_algorithm">A*_algorithm</span>
            <span class="post-date" title="2020-06-08 21:25:01">2020/06/08</span>
        </a>
        
        <a class="AI " href="/2019/05/08/DLwithPython/" data-tag="深度学习,CV,python" data-author>
            <span class="post-title" title="DeepLearning with Python">DeepLearning with Python</span>
            <span class="post-date" title="2019-05-08 17:54:01">2019/05/08</span>
        </a>
        
        <a class="三省吾身 " href="/2019/04/29/DLwords/" data-tag="AI,深度学习" data-author>
            <span class="post-title" title="DLwords">DLwords</span>
            <span class="post-date" title="2019-04-29 19:17:39">2019/04/29</span>
        </a>
        
        <a class="AI " href="/20120/09/25/DRL-report/" data-tag="数学,深度学习,强化学习" data-author>
            <span class="post-title" title="DRL_report">DRL_report</span>
            <span class="post-date" title="20120-09-25 19:17:39">20120/09/25</span>
        </a>
        
        <a class="强化学习 " href="/2019/08/05/RL-DDPG-note/" data-tag="AI,深度学习,强化学习" data-author>
            <span class="post-title" title="Aatri_A2c&amp;ppo">Aatri_A2c&amp;ppo</span>
            <span class="post-date" title="2019-08-05 21:25:01">2019/08/05</span>
        </a>
        
        <a class="强化学习 " href="/2019/09/10/RL-DP-note/" data-tag="AI,深度学习,强化学习" data-author>
            <span class="post-title" title="RL_DP">RL_DP</span>
            <span class="post-date" title="2019-09-10 21:25:01">2019/09/10</span>
        </a>
        
        <a class="强化学习 " href="/2019/08/20/RL-MP-MRP-MDP-note/" data-tag="AI,深度学习,强化学习" data-author>
            <span class="post-title" title="RL_MDP">RL_MDP</span>
            <span class="post-date" title="2019-08-20 21:25:01">2019/08/20</span>
        </a>
        
        <a class="强化学习 " href="/2020/08/02/RL-PPO-note/" data-tag="AI,深度学习,强化学习" data-author>
            <span class="post-title" title="pg_note">pg_note</span>
            <span class="post-date" title="2020-08-02 21:25:01">2020/08/02</span>
        </a>
        
        <a class="强化学习 " href="/2019/07/21/RL-basic-note/" data-tag="AI,深度学习,强化学习" data-author>
            <span class="post-title" title="rl_basic_note">rl_basic_note</span>
            <span class="post-date" title="2019-07-21 21:25:01">2019/07/21</span>
        </a>
        
        <a class="强化学习 " href="/2020/01/26/RLTF/" data-tag="AI,数学,强化学习" data-author>
            <span class="post-title" title="RLTF">RLTF</span>
            <span class="post-date" title="2020-01-26 19:21:06">2020/01/26</span>
        </a>
        
        <a class="强化学习 " href="/2020/07/31/RL_A3C_A2C_note/" data-tag="AI,深度学习,强化学习" data-author>
            <span class="post-title" title="A3C_note">A3C_note</span>
            <span class="post-date" title="2020-07-31 21:25:01">2020/07/31</span>
        </a>
        
        <a class="强化学习 " href="/2019/07/26/RL_AC-note/" data-tag="AI,深度学习,强化学习" data-author>
            <span class="post-title" title="ac_note">ac_note</span>
            <span class="post-date" title="2019-07-26 21:25:01">2019/07/26</span>
        </a>
        
        <a class="强化学习 " href="/2019/07/21/RL_pg-note/" data-tag="AI,深度学习,强化学习" data-author>
            <span class="post-title" title="pg_note">pg_note</span>
            <span class="post-date" title="2019-07-21 21:25:01">2019/07/21</span>
        </a>
        
        <a class="强化学习 " href="/2020/07/12/atari-env-note/" data-tag="编程,深度学习,强化学习" data-author>
            <span class="post-title" title="Atari游戏环境笔记">Atari游戏环境笔记</span>
            <span class="post-date" title="2020-07-12 10:00:12">2020/07/12</span>
        </a>
        
        <a class="AI " href="/2019/09/14/deep-reinforcement-learning/" data-tag="数学,深度学习,强化学习" data-author>
            <span class="post-title" title="deep-reinforcement-learning">deep-reinforcement-learning</span>
            <span class="post-date" title="2019-09-14 10:00:12">2019/09/14</span>
        </a>
        
        <a class="编程 " href="/2020/10/08/docker-base/" data-tag="编程,python,技术小节" data-author>
            <span class="post-title" title="docker-base">docker-base</span>
            <span class="post-date" title="2020-10-08 17:54:01">2020/10/08</span>
        </a>
        
        <a class="编程 " href="/2020/09/25/effective-python/" data-tag="python,技术小节" data-author>
            <span class="post-title" title="effective_python_note">effective_python_note</span>
            <span class="post-date" title="2020-09-25 19:17:39">2020/09/25</span>
        </a>
        
        <a class="编程 " href="/2019/07/23/go-http搭建服务器知识点儿/" data-tag="编程,go" data-author>
            <span class="post-title" title="go-http搭建服务器知识点儿">go-http搭建服务器知识点儿</span>
            <span class="post-date" title="2019-07-23 11:29:08">2019/07/23</span>
        </a>
        
        <a class="编程 " href="/2021/02/01/hot100/" data-tag="编程,python,技术小结" data-author>
            <span class="post-title" title="leetcodehot">leetcodehot</span>
            <span class="post-date" title="2021-02-01 20:19:39">2021/02/01</span>
        </a>
        
        <a class="编程 " href="/2020/01/31/leetcode/" data-tag="数学,编程,python" data-author>
            <span class="post-title" title="leetcode">leetcode</span>
            <span class="post-date" title="2020-01-31 10:14:45">2020/01/31</span>
        </a>
        
        <a class href="/2020/06/05/lgb-note/" data-tag="AI,编程,python" data-author>
            <span class="post-title" title="lgb_note">lgb_note</span>
            <span class="post-date" title="2020-06-05 21:25:01">2020/06/05</span>
        </a>
        
        <a class="数学 " href="/2019/04/25/math/" data-tag="AI,数学,深度学习" data-author>
            <span class="post-title" title="线性代数补充笔记">线性代数补充笔记</span>
            <span class="post-date" title="2019-04-25 21:25:01">2019/04/25</span>
        </a>
        
        <a class="AI " href="/2020/06/02/pytorch-note/" data-tag="AI,python,技术小结" data-author>
            <span class="post-title" title="pytorch_note">pytorch_note</span>
            <span class="post-date" title="2020-06-02 20:19:39">2020/06/02</span>
        </a>
        
        <a class="强化学习 " href="/2020/07/06/rl-questions/" data-tag="AI,深度学习,强化学习" data-author>
            <span class="post-title" title="RL_questions">RL_questions</span>
            <span class="post-date" title="2020-07-06 21:25:01">2020/07/06</span>
        </a>
        
        <a class="编程 " href="/2020/07/04/sword-offer03/" data-tag="python,技术小结,leetcode" data-author>
            <span class="post-title" title="剑指offer03">剑指offer03</span>
            <span class="post-date" title="2020-07-04 20:19:39">2020/07/04</span>
        </a>
        
        <a class="编程 " href="/2020/07/06/sword-offer04/" data-tag="python,技术小结,leetcode" data-author>
            <span class="post-title" title="剑指offer04">剑指offer04</span>
            <span class="post-date" title="2020-07-06 20:19:39">2020/07/06</span>
        </a>
        
        <a class="编程 " href="/2020/07/06/sword-offer05/" data-tag="python,技术小结,leetcode" data-author>
            <span class="post-title" title="剑指offer05">剑指offer05</span>
            <span class="post-date" title="2020-07-06 20:19:39">2020/07/06</span>
        </a>
        
        <a class="编程 " href="/2020/07/07/sword-offer06/" data-tag="python,技术小结,leetcode" data-author>
            <span class="post-title" title="剑指offer06">剑指offer06</span>
            <span class="post-date" title="2020-07-07 20:19:39">2020/07/07</span>
        </a>
        
        <a class="编程 " href="/2020/07/08/sword-offer07/" data-tag="python,技术小结,leetcode" data-author>
            <span class="post-title" title="剑指offer07">剑指offer07</span>
            <span class="post-date" title="2020-07-08 20:19:39">2020/07/08</span>
        </a>
        
        <a class="编程 " href="/2020/07/09/sword-offer09/" data-tag="python,技术小结,leetcode" data-author>
            <span class="post-title" title="剑指offer09">剑指offer09</span>
            <span class="post-date" title="2020-07-09 20:19:39">2020/07/09</span>
        </a>
        
        <a class="编程 " href="/2020/07/10/sword-offer10/" data-tag="python,技术小结,leetcode" data-author>
            <span class="post-title" title="剑指offer10">剑指offer10</span>
            <span class="post-date" title="2020-07-10 20:19:39">2020/07/10</span>
        </a>
        
        <a class="编程 " href="/2020/07/10/sword-offer11/" data-tag="python,技术小结,leetcode" data-author>
            <span class="post-title" title="剑指offer10">剑指offer10</span>
            <span class="post-date" title="2020-07-10 20:19:39">2020/07/10</span>
        </a>
        
        <a class="强化学习 " href="/2020/06/11/tianshou-a2c-note/" data-tag="AI,编程,强化学习" data-author>
            <span class="post-title" title="tianshou平台源码阅读笔记">tianshou平台源码阅读笔记</span>
            <span class="post-date" title="2020-06-11 21:25:01">2020/06/11</span>
        </a>
        
        <a class="强化学习 " href="/2020/10/23/tstar/" data-tag="AI,深度学习,强化学习" data-author>
            <span class="post-title" title="Tstarbots_note">Tstarbots_note</span>
            <span class="post-date" title="2020-10-23 21:25:01">2020/10/23</span>
        </a>
        
        <a class="三省吾身 " href="/2021/02/05/不正经/" data-tag="三省吾身" data-author>
            <span class="post-title" title="老不正经">老不正经</span>
            <span class="post-date" title="2021-02-05 21:12:21">2021/02/05</span>
        </a>
        
        <a class="编程 " href="/2019/04/29/使用Python实现excel中固定数据排序且改名至另一个文件夹/" data-tag="编程,python,技术小结" data-author>
            <span class="post-title" title="基于python实现excel中读取文件目录+相应数据排序+将文件重命名">基于python实现excel中读取文件目录+相应数据排序+将文件重命名</span>
            <span class="post-date" title="2019-04-29 19:30:06">2019/04/29</span>
        </a>
        
        <a class="编程 " href="/2020/07/19/动态规划/" data-tag="python,技术小结,leetcode" data-author>
            <span class="post-title" title="剑指offer10">剑指offer10</span>
            <span class="post-date" title="2020-07-19 20:19:39">2020/07/19</span>
        </a>
        
        <a class="AI " href="/2020/06/02/强化学习在滴滴网约车的应用记录/" data-tag="AI,强化学习,组会报告" data-author>
            <span class="post-title" title="强化学习在滴滴网约车的应用笔记">强化学习在滴滴网约车的应用笔记</span>
            <span class="post-date" title="2020-06-02 20:19:39">2020/06/02</span>
        </a>
        
        <a class="数学 " href="/2019/10/24/数值计算与凸优化补充笔记/" data-tag="AI,数学,深度学习" data-author>
            <span class="post-title" title="数值计算与凸优化补充笔记">数值计算与凸优化补充笔记</span>
            <span class="post-date" title="2019-10-24 16:14:54">2019/10/24</span>
        </a>
        
        <a class="三省吾身 " href="/2019/11/03/智源大会听报告笔记/" data-tag="三省吾身,AI" data-author>
            <span class="post-title" title="智源大会听学术报告笔记">智源大会听学术报告笔记</span>
            <span class="post-date" title="2019-11-03 13:24:12">2019/11/03</span>
        </a>
        
        <a class="组会报告 " href="/2019/09/26/组会报告-0930-QLearning/" data-tag="深度学习,强化学习,组会报告" data-author>
            <span class="post-title" title="组会报告-0930-QLearning">组会报告-0930-QLearning</span>
            <span class="post-date" title="2019-09-26 15:15:04">2019/09/26</span>
        </a>
        
        <a class="强化学习 " href="/2020/07/31/智能博弈挑战赛-note/" data-tag="AI,深度学习,强化学习" data-author>
            <span class="post-title" title="智能博弈挑战赛">智能博弈挑战赛</span>
            <span class="post-date" title="2020-07-31 21:25:01">2020/07/31</span>
        </a>
        
        <a class="编程 " href="/2019/09/05/物体检测打标小脚本-获取当前图片中鼠标位置/" data-tag="编程,python,技术小结" data-author>
            <span class="post-title" title="物体检测打标小脚本-获取当前图片中鼠标位置">物体检测打标小脚本-获取当前图片中鼠标位置</span>
            <span class="post-date" title="2019-09-05 15:30:36">2019/09/05</span>
        </a>
        
        <a class="三省吾身 " href="/2019/04/15/考研历程反思总结/" data-tag="三省吾身,考研" data-author>
            <span class="post-title" title="考研历程反思总结">考研历程反思总结</span>
            <span class="post-date" title="2019-04-15 21:25:01">2019/04/15</span>
        </a>
        
        <a class="AI " href="/2019/07/21/计算机视觉存疑解答记录/" data-tag="AI,数学,CV" data-author>
            <span class="post-title" title="计算机视觉存疑解答记录">计算机视觉存疑解答记录</span>
            <span class="post-date" title="2019-07-21 13:04:25">2019/07/21</span>
        </a>
        
        <a class="AI " href="/2019/07/29/达观杯比赛记录/" data-tag="三省吾身,AI,NLP" data-author>
            <span class="post-title" title="达观杯比赛记录">达观杯比赛记录</span>
            <span class="post-date" title="2019-07-29 20:19:39">2019/07/29</span>
        </a>
        
        <a class="强化学习 " href="/2019/07/06/Atari-a2c/" data-tag="AI,深度学习,强化学习" data-author>
            <span class="post-title" title="Aatri_A3C_A2c">Aatri_A3C_A2c</span>
            <span class="post-date" title="2019-07-06 21:25:01">2019/07/06</span>
        </a>
        
        <a class="编程 " href="/2020/08/05/lucifer-91/" data-tag="数学,编程,python" data-author>
            <span class="post-title" title="leetcode">leetcode</span>
            <span class="post-date" title="2020-08-05 10:14:45">2020/08/05</span>
        </a>
        
    </nav>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div class="post">
    <div class="pjax">
        <article id="post-lucifer-91" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">leetcode</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            
                <a href="javascript:" data-rel="编程">编程</a>
            
        </span>
        
        
        <span class="tag">
            
            <a href="javascript:" class="color3">数学</a>
            
            <a href="javascript:" class="color3">编程</a>
            
            <a href="javascript:" class="color2">python</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
        创建时间:<time class="date" title="更新时间: 2020-11-03 09:30:02">2020-08-05 10:14</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            阅读:<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
        <span class="top-comment" title="跳转至评论区">
            <a href="#comments">
                评论:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#90-days-追赶开始"><span class="toc-text">90 days 追赶开始</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基础篇"><span class="toc-text">基础篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数组"><span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#66-加一"><span class="toc-text">66. 加一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#75-颜色分类"><span class="toc-text">75. 颜色分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#380-常数时间插入、删除和获取随机元素"><span class="toc-text">380. 常数时间插入、删除和获取随机元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1381-设计一个支持增量操作的栈"><span class="toc-text">1381. 设计一个支持增量操作的栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#394-字符串解码"><span class="toc-text">394. 字符串解码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#232-用栈实现队列"><span class="toc-text">232. 用栈实现队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#206-反转链表"><span class="toc-text">206. 反转链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#430-扁平化多级双向链表"><span class="toc-text">430. 扁平化多级双向链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#110-平衡二叉树"><span class="toc-text">110. 平衡二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#108-将有序数组转换为二叉搜索树"><span class="toc-text">108. 将有序数组转换为二叉搜索树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#109-有序链表转换二叉搜索树"><span class="toc-text">109. 有序链表转换二叉搜索树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1382-将二叉搜索树变平衡"><span class="toc-text">1382. 将二叉搜索树变平衡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#160-相交链表"><span class="toc-text">160. 相交链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#141-环形链表"><span class="toc-text">141. 环形链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#142-环形链表-II"><span class="toc-text">142. 环形链表 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#146-LRU缓存机制"><span class="toc-text">146. LRU缓存机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#104-二叉树的最大深度"><span class="toc-text">104. 二叉树的最大深度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#100-相同的树"><span class="toc-text">100. 相同的树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#129-求根到叶子节点数字之和"><span class="toc-text">129. 求根到叶子节点数字之和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#513-找树左下角的值"><span class="toc-text">513. 找树左下角的值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#106-从中序与后序遍历序列构造二叉树"><span class="toc-text">106. 从中序与后序遍历序列构造二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#105-从前序与中序遍历序列构造二叉树"><span class="toc-text">105. 从前序与中序遍历序列构造二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#124-二叉树中的最大路径和"><span class="toc-text">124. 二叉树中的最大路径和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#124-二叉树中的最大路径和-1"><span class="toc-text">124. 二叉树中的最大路径和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-两数之和"><span class="toc-text">1. 两数之和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#447-回旋镖的数量"><span class="toc-text">447. 回旋镖的数量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#滑动窗口"><span class="toc-text">滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1456-定长子串中元音的最大数目"><span class="toc-text">1456. 定长子串中元音的最大数目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#438-找到字符串中所有字母异位词"><span class="toc-text">438. 找到字符串中所有字母异位词</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#76-最小覆盖子串"><span class="toc-text">76. 最小覆盖子串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#30-串联所有单词的子串"><span class="toc-text">30. 串联所有单词的子串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#位运算"><span class="toc-text">位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#268-缺失数字"><span class="toc-text">268. 缺失数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#78-子集"><span class="toc-text">78. 子集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#46-全排列"><span class="toc-text">46. 全排列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#47-全排列-II"><span class="toc-text">47. 全排列 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#78-子集-1"><span class="toc-text">78. 子集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#200-岛屿数量"><span class="toc-text">200. 岛屿数量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1254-统计封闭岛屿的数目"><span class="toc-text">1254. 统计封闭岛屿的数目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#130-被围绕的区域"><span class="toc-text">130. 被围绕的区域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#827-最大人工岛"><span class="toc-text">827. 最大人工岛</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#89-格雷编码"><span class="toc-text">89. 格雷编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#62-不同路径"><span class="toc-text">62. 不同路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#63-不同路径-II"><span class="toc-text">63. 不同路径 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#980-不同路径-III"><span class="toc-text">980. 不同路径 III</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#322-零钱兑换"><span class="toc-text">322. 零钱兑换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#518-零钱兑换-II"><span class="toc-text">518. 零钱兑换 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#416-分割等和子集"><span class="toc-text">416. 分割等和子集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#494-目标和"><span class="toc-text">494. 目标和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#474-一和零"><span class="toc-text">474. 一和零</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#746-使用最小花费爬楼梯"><span class="toc-text">746. 使用最小花费爬楼梯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#790-多米诺和托米诺平铺"><span class="toc-text">790. 多米诺和托米诺平铺</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#935-骑士拨号器"><span class="toc-text">935. 骑士拨号器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1458-两个子序列的最大点积"><span class="toc-text">1458. 两个子序列的最大点积</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#96-不同的二叉搜索树"><span class="toc-text">96. 不同的二叉搜索树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23-合并K个升序链表"><span class="toc-text">23. 合并K个升序链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#881-救生艇"><span class="toc-text">881. 救生艇</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#765-情侣牵手"><span class="toc-text">765. 情侣牵手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#136-只出现一次的数字"><span class="toc-text">136. 只出现一次的数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#137-只出现一次的数字-II"><span class="toc-text">137. 只出现一次的数字 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#645-错误的集合"><span class="toc-text">645. 错误的集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#面试题-04-01-节点间通路"><span class="toc-text">面试题 04.01. 节点间通路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#547-朋友圈"><span class="toc-text">547. 朋友圈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#684-冗余连接"><span class="toc-text">684. 冗余连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#149-直线上最多的点数"><span class="toc-text">149. 直线上最多的点数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#222-完全二叉树的节点个数"><span class="toc-text">222. 完全二叉树的节点个数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-盛最多水的容器"><span class="toc-text">11. 盛最多水的容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#875-爱吃香蕉的珂珂"><span class="toc-text">875. 爱吃香蕉的珂珂</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26-删除排序数组中的重复项"><span class="toc-text">26. 删除排序数组中的重复项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#167-两数之和-II-输入有序数组"><span class="toc-text">167. 两数之和 II - 输入有序数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#42-接雨水"><span class="toc-text">42. 接雨水</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1002-查找常用字符"><span class="toc-text">1002. 查找常用字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#面试题-17-11-单词距离"><span class="toc-text">面试题 17.11. 单词距离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#581-最短无序连续子数组"><span class="toc-text">581. 最短无序连续子数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#763-划分字母区间"><span class="toc-text">763. 划分字母区间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#78-子集-2"><span class="toc-text">78. 子集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#62-不同路径-1"><span class="toc-text">62. 不同路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-有效的括号"><span class="toc-text">20. 有效的括号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32-最长有效括号"><span class="toc-text">32. 最长有效括号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#206-反转链表-1"><span class="toc-text">206. 反转链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#92-反转链表-II"><span class="toc-text">92. 反转链表 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25-K-个一组翻转链表"><span class="toc-text">25. K 个一组翻转链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#208-实现-Trie-前缀树"><span class="toc-text">208. 实现 Trie (前缀树)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#144-二叉树的前序遍历"><span class="toc-text">144. 二叉树的前序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#821-字符的最短距离"><span class="toc-text">821. 字符的最短距离</span></a></li></ol></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本笔记主要是跟着lucifer大佬刷leetcode巩固数据结构知识笔记</p>
<a id="more"></a>
<h1 id="90-days-追赶开始"><a href="#90-days-追赶开始" class="headerlink" title="90 days 追赶开始"></a>90 days 追赶开始</h1><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>之前学习数组疏忽的一个点是插入数组和删除数组的时间复杂度问题：</p>
<blockquote>
<ul>
<li>随机访问 -&gt; O(1)</li>
<li>根据索引修改 -&gt; O(1)</li>
<li>遍历数组 -&gt; O(N)</li>
<li>插入数值到数组 -&gt; O(N)</li>
<li>删除数值-&gt;O(N)</li>
<li>插入数值到数组最后 -&gt; O(1)</li>
<li>从数组最后删除数值 -&gt; O(1)</li>
</ul>
</blockquote>
<p>而<strong>栈和队列</strong>的插入与删除的时间复杂度都是O(1)</p>
<p>对于单队列来讲：</p>
<ul>
<li>只有头指针，不管是否含头节点：出队的时间复杂度为O(1)，入队的时间复杂度为O(N)</li>
<li>只有尾指针，出队和入队的时间复杂度为O(1)</li>
</ul>
<p>对于循环队列来讲(用的不多)：</p>
<ul>
<li>如果只有头指针，不含头节点，出队则为O(N)</li>
</ul>
<h4 id="66-加一"><a href="#66-加一" class="headerlink" title="66. 加一"></a><a href="https://leetcode-cn.com/problems/plus-one/" target="_blank" rel="noopener">66. 加一</a></h4><p>第一种解法是挨个判断（好像有点暴力？）</p>
<pre><code class="lang-(python)">class Solution:
    def plusOne(self, digits: List[int]) -&gt; List[int]:
        length = len(digits)
        i = length-1
        while i&gt;=0:
            if digits[i]==9:
                digits[i]=0
                i-=1#如果当前为9，就改变这个数为0，再向左走
                if i&lt;0:#对应输入为[9],判断向左走到头了就需要再新增一位
                    digits.insert(0,1)
            else:
                digits[i] += 1
                break#如果不是9直接加1即可
        return digits
</code></pre>
<p>看了评论区的另一种解法是先将数组转为数字，+1，再转为数组转为字符串再分别将每个字符拿出来放到列表中</p>
<pre><code class="lang-(python)">class Solution:
    def plusOne(self, digits: List[int]) -&gt; List[int]:
        sums = 0
        for i in range(1,len(digits)+1):
            sums+=10**(len(digits)-i)*digits[i-1]
        sum_str = str(sums+1)
        return [int(j) for j in sum_str]
</code></pre>
<h4 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a><a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">75. 颜色分类</a></h4><p>经过leetcode的提示写出来的较为笨重的解法：</p>
<blockquote>
<p>一个直观的解决方案是使用计数排序的两趟扫描算法。<br>首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。</p>
</blockquote>
<pre><code class="lang-python">class Solution:
    def sortColors(self, nums: List[int]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
        n = len(nums)
        num_1 = 0
        num_0 = 0
        for i in nums:
            if i==0:
                num_0+=1
            if i==1:
                num_1+=1
        num_2 = n-num_1-num_0
        for i in range(num_0):
            nums[i] = 0
        for i in range(num_0,num_0+num_1):
            nums[i] = 1
        for i in range(num_0+num_1,n):
            nums[i] = 2
</code></pre>
<p>按照我的理解，这道题本质上是排序的题，所以可以选择一种符合“原地”要求的排序算法来解题</p>
<p>官方题解可以看为一种三路快速排序,其中较为重要的一点是什么时候右移curr，什么时候不动</p>
<p>在这里的理解是：curr是从左向右进行遍历，如果curr是0，与p0所指的元素进行交换，因为p0是随着curr走出来的，不是0就是1，肯定没问题，交换之后可以+1</p>
<p>而如果curr是2，与p1交换只能保证p2的右面肯定是2，不能保证p2交换后得来的东西是啥，所以不能盲目将curr+1，需要再进行判断</p>
<pre><code class="lang-python">class Solution:
    def sortColors(self, nums: List[int]) -&gt; None:
        &#39;&#39;&#39;
        荷兰三色旗问题解
        &#39;&#39;&#39;
        # 对于所有 idx &lt; p0 : nums[idx &lt; p0] = 0
        # curr是当前考虑元素的下标
        p0 = curr = 0
        # 对于所有 idx &gt; p2 : nums[idx &gt; p2] = 2
        p2 = len(nums) - 1

        while curr &lt;= p2:
            if nums[curr] == 0:
                nums[p0], nums[curr] = nums[curr], nums[p0]
                p0 += 1
                curr += 1
            elif nums[curr] == 2:
                nums[curr], nums[p2] = nums[p2], nums[curr]
                p2 -= 1
            else:
                curr += 1

作者：LeetCode
链接：https://leetcode-cn.com/problems/sort-colors/solution/yan-se-fen-lei-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<h4 id="380-常数时间插入、删除和获取随机元素"><a href="#380-常数时间插入、删除和获取随机元素" class="headerlink" title="380. 常数时间插入、删除和获取随机元素"></a><a href="https://leetcode-cn.com/problems/insert-delete-getrandom-o1/" target="_blank" rel="noopener">380. 常数时间插入、删除和获取随机元素</a></h4><p>在markdown中讲过数组的操作的时间复杂度如下</p>
<blockquote>
<ul>
<li>随机访问 -&gt; O(1)</li>
<li>根据索引修改 -&gt; O(1)</li>
<li>遍历数组 -&gt; O(N)</li>
<li>插入数值到数组 -&gt; O(N)</li>
<li>删除数值-&gt;O(N)</li>
<li>插入数值到数组最后 -&gt; O(1)</li>
<li>从数组最后删除数值 -&gt; O(1)</li>
</ul>
</blockquote>
<p>结合着评论知道了用常数时间实现插入，删除，获取随机元素的根本在于用一个字典来记录元素对应的位置，因为字典的查找是O(1)的，然后再交换指定元素与想要删除的元素即可避免删除元素后面的依次挪动</p>
<p>关于字典的查找的时间复杂度为O(1)的解释可见<a href="https://blog.csdn.net/Java_Cappuccino/article/details/107644418" target="_blank" rel="noopener">https://blog.csdn.net/Java_Cappuccino/article/details/107644418</a></p>
<p>且关于此题无需想的过于复杂（我一开始以为需要将元素插入到指定位置）</p>
<pre><code class="lang-python">class RandomizedSet:

    def __init__(self):
        &quot;&quot;&quot;
        Initialize your data structure here.
        &quot;&quot;&quot;
        self.mem = {}#用于记录位置,键是实际数值，值是在nums的位置
        self.nums = []#用于记录数字


    def insert(self, val: int) -&gt; bool:
        &quot;&quot;&quot;
        Inserts a value to the set. Returns true if the set did not already contain the specified element.
        &quot;&quot;&quot;
        if val in self.nums:
            return False
        else:
            self.mem[val] = len(self.nums)#将这个插入数字与其所在列表的位置用字典记录下来
            self.nums.append(val)
            return True


    def remove(self, val: int) -&gt; bool:
        &quot;&quot;&quot;
        Removes a value from the set. Returns true if the set contained the specified element.
        &quot;&quot;&quot;
        if val not in self.nums:#先判断要删除的是否在数组里面
            return False
        else:
            last_val = self.nums[-1]#最后一个元素的值
            last_index = self.mem[last_val]#找到nums最后一个元素所对应的位置或者叫索引
            target_index = self.mem[val]#找到想要删除元素的索引
            self.nums[target_index],self.nums[last_index]=self.nums[last_index],self.nums[target_index]#交换数组
            self.mem[last_val],self.mem[val] = target_index,last_index
            self.nums.pop()
            self.mem.pop(val)#删除数组的交换后的最后一个元素和字典的指定元素
            return True    


    def getRandom(self) -&gt; int:
        &quot;&quot;&quot;
        Get a random element from the set.
        &quot;&quot;&quot;
        return self.nums[random.randint(0,len(self.nums)-1)]



# Your RandomizedSet object will be instantiated and called as such:
# obj = RandomizedSet()
# param_1 = obj.insert(val)
# param_2 = obj.remove(val)
# param_3 = obj.getRandom()
</code></pre>
<h4 id="1381-设计一个支持增量操作的栈"><a href="#1381-设计一个支持增量操作的栈" class="headerlink" title="1381. 设计一个支持增量操作的栈"></a><a href="https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/" target="_blank" rel="noopener">1381. 设计一个支持增量操作的栈</a></h4><p>花了一个小时试出来的垃圾写法:</p>
<pre><code class="lang-python">class CustomStack:

    def __init__(self, maxSize: int):
        self.maxSize = maxSize
        self.stack = [None]*maxSize
        self.length = 0


    def push(self, x: int) -&gt; None:
        if self.length&lt;self.maxSize-1:
            self.stack[self.length] = x
            self.length+=1
        elif self.length==self.maxSize-1 and self.stack[-1]==None:
            self.stack[self.length] = x
            self.length+=1



    def pop(self) -&gt; int:

        if self.length&gt;0 and (self.stack[-1] is None):
            tmp = self.stack[self.length-1]
            self.stack[self.length-1] = None
            self.length-=1
            return tmp          
        elif self.length&gt;0 and (self.stack[-1] is not None):
            self.length-=1
            tmp = self.stack[self.length]
            self.stack[self.length] = None
            #一开始错在这种情况直接pop导致数组的长度变短，再执行push的时候发现找不到那么长的位置，所以在push那里报错
            return tmp
        elif self.length == 0:
            return -1



    def increment(self, k: int, val: int) -&gt; None:
        if k&gt;=self.length:
            for i in range(self.length):
                self.stack[i]+=val
        elif k&lt;self.length:
            for i in range(k):
                self.stack[i]+=val



# Your CustomStack object will be instantiated and called as such:
# obj = CustomStack(maxSize)
# obj.push(x)
# param_2 = obj.pop()
# obj.increment(k,val)
</code></pre>
<p>把不必要的判断条件优化一下：</p>
<pre><code class="lang-python">class CustomStack:
    def __init__(self, maxSize: int):
        self.maxSize = maxSize
        self.stack = [None]*maxSize
        self.length = 0

    def push(self, x: int) -&gt; None:
        if self.length&lt;self.maxSize-1:
            self.stack[self.length] = x
            self.length+=1
        elif self.length==self.maxSize-1:
            self.stack[self.length] = x
            self.length+=1

    def pop(self) -&gt; int:
        if self.length&gt;0 :
            tmp = self.stack[self.length-1]
            self.stack[self.length-1] = None
            self.length-=1
            return tmp          
        #一开始错在这种情况直接pop导致数组的长度变短，再执行push的时候发现找不到那么长的位置，所以在push那里报错
        elif self.length == 0:
            return -1

    def increment(self, k: int, val: int) -&gt; None:
        if k&gt;=self.length:
            for i in range(self.length):
                self.stack[i]+=val
        elif k&lt;self.length:
            for i in range(k):
                self.stack[i]+=val

# Your CustomStack object will be instantiated and called as such:
# obj = CustomStack(maxSize)
# obj.push(x)
# param_2 = obj.pop()
# obj.increment(k,val)
</code></pre>
<p>看了题解发现被一句话<strong>误导</strong>了？</p>
<blockquote>
<p>用 <code>maxSize</code> 初始化对象</p>
</blockquote>
<p>很多题解中在初始化的时候直接令self.stack = []省区很多判断条件</p>
<p>如<strong><a href="https://github.com/syhwawa" target="_blank" rel="noopener">syhwawa</a></strong>老哥的题解</p>
<pre><code class="lang-python">class CustomStack:
    #Use length to define the maxsize

    def __init__(self, maxSize: int):
        self.stack = []
        self.length = maxSize

    def push(self, x: int) -&gt; None:
        if len(self.stack) &lt; self.length:
            self.stack.append(x)

    def pop(self) -&gt; int:
        if len(self.stack) == 0:
            return -1
        return self.stack.pop()

    def increment(self, k: int, val: int) -&gt; None:
        for i in range(min(k, len(self.stack))):
            self.stack[i] += val
</code></pre>
<p>还需注意的一点是官方题解中的使用self.top来记录stack列表的右端，在执行pop()函数的时候直接让top-=1，再返回该元素即可。与官方题解相比，自己写的slef.length的作用与self.top指针类似，我的写法中有个不必要的操作是执念于在pop后修改length后面的元素，其实是没必要的，因为在push的时候会以赋值的方式进行改变，</p>
<ul>
<li>self.stk = [0] <em> maxSize 或者self.stk = [None] </em> maxSize &amp; push赋值&amp;pop不对列表进行改变</li>
<li>self.stack = [] &amp;push使用append&amp;pop()使用stack.pop()对列表进行改变</li>
</ul>
<h4 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a><a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">394. 字符串解码</a></h4><p>参考<a href="https://leetcode-cn.com/problems/decode-string/solution/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/decode-string/solution/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/</a></p>
<p>重点是使用stack列表存储的是上一轮的字符串和当前字符串重复的次数</p>
<pre><code class="lang-python">class Solution:
    def decodeString(self, s: str) -&gt; str:
        ans = &#39;&#39;
        stack = []
        num = 0
        for i in range(len(s)):
            if s[i]==&#39;[&#39;:
                stack.append([num,ans])#放到栈里面的是暂时的字符串与个数的匹配对儿
                num = 0
                ans = &#39;&#39;
            elif s[i] == &#39;]&#39;:
                num_now,ans_last = stack.pop()
                print(num_now)
                print(ans)
                print(ans_last)
                ans = ans_last+num_now*ans
            elif &#39;0&#39;&lt;=s[i]&lt;=&#39;9&#39;:
                num = num*10+int(s[i])
            else:
                ans+=s[i]
        return ans
</code></pre>
<h4 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">232. 用栈实现队列</a></h4><p>注意本题是两个栈实现的队列，一个入，一个出，只有当出栈为空了才将入栈都导出去给出栈，且判断是否为空也需要判断两个栈</p>
<pre><code class="lang-python">class MyQueue:

    def __init__(self):
        &quot;&quot;&quot;
        Initialize your data structure here.
        &quot;&quot;&quot;
        self.instack = []
        self.outstack = []


    def push(self, x: int) -&gt; None:
        &quot;&quot;&quot;
        Push element x to the back of queue.
        &quot;&quot;&quot;
        self.instack.append(x)


    def pop(self) -&gt; int:
        &quot;&quot;&quot;
        Removes the element from in front of queue and returns that element.
        &quot;&quot;&quot;
        if len(self.outstack)==0:
            while self.instack:
                self.outstack.append(self.instack.pop())
        return self.outstack.pop()


    def peek(self) -&gt; int:
        &quot;&quot;&quot;
        Get the front element.
        &quot;&quot;&quot;
        if len(self.outstack) == 0:
            while self.instack:
                self.outstack.append(self.instack.pop())
        return self.outstack[-1]


    def empty(self) -&gt; bool:
        &quot;&quot;&quot;
        Returns whether the queue is empty.
        &quot;&quot;&quot;
        return len(self.instack)==0 and len(self.outstack)==0



# Your MyQueue object will be instantiated and called as such:
# obj = MyQueue()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.peek()
# param_4 = obj.empty()
</code></pre>
<h4 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. 反转链表</a></h4><p>共使用三个指针分别向后移动，之前，现在，之后（用tmp存储）</p>
<pre><code class="lang-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseList(self, head: ListNode) -&gt; ListNode:
        &quot;&quot;&quot;
        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        pre = None
        current = head
        while current:
            tmp = current.next
            current.next = pre
            pre = current
            current = tmp
        return pre
</code></pre>
<p>需要用栈实现迭代：</p>
<p>两点需要注意：</p>
<ul>
<li>用ans.next.next再指回来自己实现反转</li>
<li>ans在入栈的时候已经逐步向后移动指向最后一个节点，所以返回的时候是返回“ans”</li>
<li>在最开始特殊判断这个head链表是否为空</li>
</ul>
<pre><code class="lang-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseList(self, head: ListNode) -&gt; ListNode:
        &quot;&quot;&quot;
        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        pre = None
        ans = head
        stack = []
        if ans is None:
            return []
        while ans.next is not None:
            stack.append(ans)
            ans = ans.next
        while len(stack)&gt;0:
            current = stack.pop()
            current.next.next = current
        head.next = None
        return ans
</code></pre>
<h4 id="430-扁平化多级双向链表"><a href="#430-扁平化多级双向链表" class="headerlink" title="430. 扁平化多级双向链表"></a><a href="https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/" target="_blank" rel="noopener">430. 扁平化多级双向链表</a></h4><p>仿照<strong><a href="https://github.com/lyonyang" target="_blank" rel="noopener">lyonyang</a></strong>大佬写的，思路是使用dfs将树的节点都加到数组里面，注意这里不能只是append（node.val），因为在底下还需要再将这些节点的prev和next串起来，且child需要置为空</p>
<pre><code class="lang-python">class Solution:
    def flatten(self, head: &#39;Node&#39;) -&gt; &#39;Node&#39;:
        if head == None:
            return head
        # 前序遍历
        ans = []
        def dfs(node):
            if node:
                ans.append(node)
                if node.child:
                    dfs(node.child)
                if node.next:
                    dfs(node.next)
        dfs(head)
        for i in range(len(ans)):
            if i==0:
                prev = None
            else:
                prev = ans[i-1]
            if i==len(ans)-1:
                next = None
            else:
                next = ans[i+1]
            ans[i].prev = prev
            ans[i].next = next
            ans[i].child = None
        return ans[0]
</code></pre>
<p>官方题解的第二种解法需要注意的是一定要在最后将1这个头节点的prev指向None，因为最后想要的是</p>
<p>None&lt;-1&lt;=&gt;2&lt;=&gt;3….</p>
<p>而不是</p>
<p>None&lt;=&gt;1&lt;=&gt;2&lt;=&gt;3</p>
<pre><code class="lang-python">&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val, prev, next, child):
        self.val = val
        self.prev = prev
        self.next = next
        self.child = child
&quot;&quot;&quot;

class Solution:
    def flatten(self, head: &#39;Node&#39;) -&gt; &#39;Node&#39;:
        if head == None:
            return head
        # 使用栈来辅助前序遍历
        before_first = Node(None,None,head,None)
        prev = before_first
        stack = []
        stack.append(head)
        while stack:
            curr = stack.pop()
            prev.next = curr
            curr.prev = prev
            if curr.next:
                stack.append(curr.next)#右
            if curr.child:
                stack.append(curr.child)#左
                curr.child = None
            prev = curr
        before_first.next.prev = None
        return before_first.next
</code></pre>
<h4 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">110. 平衡二叉树</a></h4><p>计算根节点左右以及左子树的左右….的高度差，如果都相差小于2则是平衡二叉树，否则就False</p>
<pre><code class="lang-python">class Solution:
    def isBalanced(self, root: TreeNode) -&gt; bool:
        return self.depth(root)!=-1
    def depth(self,root):
        if not root:
            return 0
        left = self.depth(root.left)
        if left ==-1:
            return -1
        right = self.depth(root.right)
        if right==-1:
            return -1
        return max(left,right)+1 if abs(left-right)&lt;2 else -1
</code></pre>
<h4 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">108. 将有序数组转换为二叉搜索树</a></h4><p>有序数组的中点即为二叉搜索树的根，</p>
<pre><code class="lang-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def sortedArrayToBST(self, nums: List[int]) -&gt; TreeNode:
        def helper(left,right):
            if left&gt;right:
                return None
            p = (left+right)//2
            root = TreeNode(nums[p])
            root.left = helper(left,p-1)
            root.right = helper(p+1,right)
            return root
        return helper(0,len(nums)-1)
</code></pre>
<h4 id="109-有序链表转换二叉搜索树"><a href="#109-有序链表转换二叉搜索树" class="headerlink" title="109. 有序链表转换二叉搜索树"></a><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="noopener">109. 有序链表转换二叉搜索树</a></h4><p>将有序链表转化为有序数组，再将108的helper移植过来即可</p>
<pre><code class="lang-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def sortedListToBST(self, head: ListNode) -&gt; TreeNode:
        nums = []
        while head:
            nums.append(head.val)
            head = head.next
        print(nums)
        def helper(left,right):
            if left&gt;right:
                return None
            p = (left+right)//2
            root = TreeNode(nums[p])
            root.left = helper(left,p-1)
            root.right = helper(p+1,right)
            return root
        return helper(0,len(nums)-1)
</code></pre>
<p>快慢指针：</p>
<p>思想是慢的走一步，快的走两步，当快指针走到结尾处慢指针的val就是中间节点，将该节点作为根节点，其左子树的根是对head到pre执行sortedListToBST得到的节点，右节点也是如此，递归（自己调用自己），需要特别注意的是要把左半部分的结尾pre的next指向None</p>
<pre><code class="lang-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def sortedListToBST(self, head: ListNode) -&gt; TreeNode:
        if not head:
            return head
        pre,slow,fast = None,head,head
        while fast and fast.next:
            fast = fast.next.next#fast一次走两步
            pre = slow
            slow = slow.next#slow一次走一步
        if pre:
            pre.next = None
        node = TreeNode(slow.val)
        if slow == fast:
            return node
        node.left = self.sortedListToBST(head)
        node.right = self.sortedListToBST(slow.next)
        return node
</code></pre>
<h4 id="1382-将二叉搜索树变平衡"><a href="#1382-将二叉搜索树变平衡" class="headerlink" title="1382. 将二叉搜索树变平衡"></a><a href="https://leetcode-cn.com/problems/balance-a-binary-search-tree/" target="_blank" rel="noopener">1382. 将二叉搜索树变平衡</a></h4><p>思路是利用中序遍历先将二叉搜索树转化为递增数组，再用108的helper</p>
<pre><code class="lang-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def balanceBST(self, root: TreeNode) -&gt; TreeNode:
        #先将二叉搜索树中序遍历转化为递增数组
        def inorder(node):
            if not node:
                return []
            return inorder(node.left)+[node.val]+inorder(node.right)
        nums = inorder(root)
        def helper(left,right):
            if left&gt;right:
                return None
            p = (left+right)//2
            root = TreeNode(nums[p])
            root.left = helper(left,p-1)
            root.right = helper(p+1,right)
            return root
        return helper(0,len(nums)-1)
</code></pre>
<h4 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">160. 相交链表</a></h4><p>只要ha不等于hb，就让他们一直指向自己的next，直到其中一个先走完让其指向另一个链表的开端，这样如果headA和headB有公共的节点，他们就一定会相等</p>
<pre><code class="lang-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:
        ha,hb = headA,headB
        while ha!=hb:
            ha = ha.next if ha else headB
            hb = hb.next if hb else headA
        return ha
</code></pre>
<h4 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141. 环形链表</a></h4><p>思路：快慢指针</p>
<pre><code class="lang-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def hasCycle(self, head: ListNode) -&gt; bool:
        fast,slow = head,head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
            if fast==slow:
                return True
        return False
</code></pre>
<h4 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">142. 环形链表 II</a></h4><p>想法出自评论区的神仙<a href="https://leetcode-cn.com/u/dongfan/" target="_blank" rel="noopener">dongfan</a></p>
<pre><code class="lang-python">class Solution(object):
    &quot;&quot;&quot;
    原理：首先初始化快指针 fast = head.next.next 和 slow = head.next，
    此时快指针走的路长为2, m慢指针走的路长为1，之后令快指针每次走两步，
    慢指针每次走一步，这样快指针走的路长始终是慢指针走的路长的两倍，
    若不存在环，直接返回None，
    若存在环，则 fast 与 slow 肯定会在若干步之后相遇；

    性质1：
        设从head需要走 a 步到达环的入口，如果环存在的话，
        再走 b 步可以再次到达该入口（即环的长度为b），
        如果存在环的话，上述描述的 快指针 fast 和 
        慢指针slow 必然会相遇，且此时slow走的路长
        小于 a + b(可以自行证明)，设其为 a + x，
        当快慢指针相遇时，快指针已经至少走完一圈环了，
        不妨设相遇时走了完整的m圈(m &gt;= 1)，有：

        快指针走的路长为 a + mb + x
        慢指针走的路长为 a + x

        由于快指针fast 走的路长始终是慢指针的 2倍，所以：

        a + mb + x = 2(a + x)

        化简可得：

        a = mb - x  -------------  (*)

    当快指针与慢指针相遇时，由于 &lt;性质1&gt; 的存在，
    可以在链表的开头初始化一个新的指针，
    称其为 detection, 此时 detection 距离环的入口的距离为 a，

    此时令 detection 和 fast 每次走一步，
    会发现当各自走了 a 步之后，两个指针同时到达了环的入口，理由分别如下：

    detection不用说了，走了a步肯定到刚好到入口
    fast已经走过的距离为 a + mb + x，当再走 a 步之后，
    fast走过的总距离为 2a + mb + x，带入性质1的(*)式可得：
    2a + mb + x = a + 2mb，会发现，fast此时刚好走完了
    整整 2m 圈环，正好处于入口的位置。

    基于此，我们可以进行循环，直到 detection 和 
    fast 指向同一个对象，此时指向的对象恰好为环的入口。

    &quot;&quot;&quot;
    def detectCycle(self, head):
        &quot;&quot;&quot;
        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        # 首先初始化快指针和慢指针，确保快指针走的路的长度是慢指针长度的2倍
        if head and head.next:
            fast = head.next.next
            slow = head.next
        else:
            return None  # 说明无环

        # 进行循环，首先让快指针和慢指针第一次相遇
        while fast:
            if fast != slow:

                # 快指针走两步
                if fast.next:
                    fast = fast.next.next
                else:
                    return None  # 说明无环

                # 慢指针走一步
                slow = slow.next
            else:
                detection = head
                while detection != slow:  # 此时由于slow和fast是一样的，用哪个都行
                    slow = slow.next
                    detection = detection.next

                return detection
</code></pre>
<h4 id="146-LRU缓存机制"><a href="#146-LRU缓存机制" class="headerlink" title="146. LRU缓存机制"></a><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU缓存机制</a></h4><p>看评论区最基础的写法：</p>
<p>时空都是O(N)</p>
<pre><code class="lang-python">class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.dict_keys_values = {}
        self.list_keys = []

    def get(self, key: int) -&gt; int:
        if key in self.list_keys:
            index = self.list_keys.index(key)
            del self.list_keys[index]
            self.list_keys.append(key)
            return self.dict_keys_values[key]
        else:
            return -1

    def put(self, key: int, value: int) -&gt; None:
        if len(self.list_keys)&lt;self.capacity:
            if key not in self.list_keys:
                self.list_keys.append(key)
                self.dict_keys_values[key] = value
            else:
                index = self.list_keys.index(key)
                del self.list_keys[index]
                self.dict_keys_values[key] = value
                self.list_keys.append(key)
        else:
            if key in self.list_keys:
                index = self.list_keys.index(key)
                del self.list_keys[index]
                self.dict_keys_values[key] = value
                self.list_keys.append(key)
            else:
                del self.dict_keys_values[self.list_keys[0]]
                del self.list_keys[0]
                self.list_keys.append(key)
                self.dict_keys_values[key] = value

# Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)
</code></pre>
<p>改进：双向链表</p>
<pre><code class="lang-python">class ListNode:
    def __init__(self, key=None, value=None):
        self.key = key
        self.value = value
        self.prev = None
        self.next = None

class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.dict_keys_values = {}
        self.head = ListNode()
        self.tail = ListNode()
        self.head.next=self.tail
        self.tail.prev = self.head


    def get(self, key: int) -&gt; int:
        if key in self.dict_keys_values:
            self.move_node_to_tail(key)
        ans = self.dict_keys_values.get(key,-1)
        if ans == -1:
            return ans
        else:
            return ans.value



    def put(self, key: int, value: int) -&gt; None:
        if key in self.dict_keys_values:
            self.dict_keys_values[key].value = value
            self.move_node_to_tail(key)
        else:
            if len(self.dict_keys_values)==self.capacity:
                self.dict_keys_values.pop(self.head.next.key)
                self.head.next = self.head.next.next
                self.head.next.prev = self.head
            new = ListNode(key, value)
            self.dict_keys_values[key] = new
            new.prev = self.tail.prev
            new.next = self.tail
            self.tail.prev.next = new
            self.tail.prev = new
    def move_node_to_tail(self,key):
        node = self.dict_keys_values[key]
        node.prev.next = node.next
        node.next.prev = node.prev
        node.prev = self.tail.prev
        node.next = self.tail
        self.tail.prev.next = node
        self.tail.prev = node

# 作者：liye-3
# 链接：https://leetcode-cn.com/problems/lru-cache/solution/shu-ju-jie-gou-fen-xi-python-ha-xi-shuang-xiang-li/
# 来源：力扣（LeetCode）
# 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

# Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)
</code></pre>
<h4 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">104. 二叉树的最大深度</a></h4><pre><code class="lang-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def maxDepth(self, root: TreeNode) -&gt; int:
        if root is None:
            return 0
        self.ans = 0
        self._dfs(root,0)
        return self.ans
    def _dfs(self,node,level):
        if not node:
            return
        if self.ans&lt;level+1:
            self.ans = level+1
        self._dfs(node.left,level+1)
        self._dfs(node.right,level+1)
</code></pre>
<h4 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a><a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener">100. 相同的树</a></h4><pre><code class="lang-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -&gt; bool:
        if not p and not q:
            return True
        elif not p or not q:
            return False
        elif p.val!=q.val:
            return False
        elif p.val == q.val:
            return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)
</code></pre>
<h4 id="129-求根到叶子节点数字之和"><a href="#129-求根到叶子节点数字之和" class="headerlink" title="129. 求根到叶子节点数字之和"></a><a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener">129. 求根到叶子节点数字之和</a></h4><pre><code class="lang-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def sumNumbers(self, root: TreeNode) -&gt; int:
        self.res = 0
        def helper(root,tmp):
            if not root:return 
            if not root.left and not root.right:
                self.res+=int(tmp+str(root.val))
                return
            helper(root.left,tmp+str(root.val))
            helper(root.right,tmp+str(root.val))
        helper(root,&#39;&#39;)
        return self.res
</code></pre>
<h4 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513. 找树左下角的值"></a><a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/" target="_blank" rel="noopener">513. 找树左下角的值</a></h4><p>思路是根右左的顺序遍历，最后一个肯定是答案所要求的</p>
<pre><code class="lang-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def findBottomLeftValue(self, root: TreeNode) -&gt; int:
        queue = [root]
        while queue:
            cur = queue.pop(0)
            if cur.right:
                queue.append(cur.right)
            if cur.left:
                queue.append(cur.left)
        return cur.val
</code></pre>
<h4 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">106. 从中序与后序遍历序列构造二叉树</a></h4><p>因为后序遍历是左右根，思路是依靠后序遍历中的最后一个节点为切割点，将该切割点在中序遍历的位置找到，中序遍历的左面就是左子树，右面就是右子树，再将左右子树再按照此种方法套娃。</p>
<p>容易陷进去的点是为啥中序遍历中得到的根节点的位置在前序遍历中也可以用？</p>
<p>就是中序和后序的共同特点就是都先遍历左子树，左面遍历完了才搞右面或者根节点，所以左面一点是个数相同的一些节点的不同组合。</p>
<pre><code class="lang-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -&gt; TreeNode:
        # 实际上inorder 和 postorder一定是同时为空的，因此你无论判断哪个都行
        if not inorder:
            return None
        root = TreeNode(postorder[-1])
        i = inorder.index(root.val)
        root.left = self.buildTree(inorder[:i], postorder[:i])
        root.right = self.buildTree(inorder[i+1:], postorder[i:-1])

        return root

# 作者：fe-lucifer
# 链接：https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/si-lu-qing-xi-dai-ma-jian-ji-he-105ti-si-lu-yi-zhi/
# 来源：力扣（LeetCode）
# 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<p>同理</p>
<h4 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">105. 从前序与中序遍历序列构造二叉树</a></h4><pre><code class="lang-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:
        if not preorder:
            return None
        root = TreeNode(preorder[0])
        i = inorder.index(root.val)
        root.left = self.buildTree(preorder[1:i+1],inorder[:i])
        root.right = self.buildTree(preorder[i+1:],inorder[i+1:])
        return root
</code></pre>
<h4 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">124. 二叉树中的最大路径和</a></h4><pre><code class="lang-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def maxPathSum(self, root: TreeNode) -&gt; int:
        self.ans = float(&#39;-inf&#39;)
        def dfs(root):
            if not root:
                return 0
            left = dfs(root.left)
            right = dfs(root.right)
            self.ans = max(self.ans,left+right+root.val)
            return max(0,max(left,right)+root.val)
        dfs(root)
        return self.ans
</code></pre>
<p>遗留问题：为什么self.ans设置为inf返回值不是inf而是null？</p>
<h4 id="124-二叉树中的最大路径和-1"><a href="#124-二叉树中的最大路径和-1" class="headerlink" title="124. 二叉树中的最大路径和"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">124. 二叉树中的最大路径和</a></h4><p>这里需要注意的2情况分别是：</p>
<p>1.当前节点是当作根节点来看待：</p>
<p>当前节点+左子树</p>
<p>当前节点+右子树</p>
<p>当前节点+左右子树</p>
<p>2.当前节点作为父节点的一个子节点来看待</p>
<p>比较value1到value3即可</p>
<pre><code class="lang-pythno"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def maxPathSum(self, root: TreeNode) -&gt; int:
        self.ans = float(&#39;-inf&#39;)
        def dfs(root):
            if not root:
                return 0
            left = dfs(root.left)
            right = dfs(root.right)
            self.ans = max(self.ans,left+right+root.val)
            return max(0,max(left,right)+root.val)
        dfs(root)
        return self.ans
</code></pre>
<h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和</a></h4><p>两种做法：</p>
<p>1.使用字典，将遍历到的值都放到字典（哈希表）中，以数值为键，以索引为值再找与之相对应的数值，用带有索引的哈希表肯定比第二种方法快很多</p>
<pre><code class="lang-python">class Solution:
    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:
        hashmap = {}
        for index,num in enumerate(nums):
            another_num = target - num
            if another_num in hashmap:
                return [hashmap[another_num],index]
            hashmap[num] = index
        return None
</code></pre>
<pre><code class="lang-python">class Solution:
    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:
        for index,num in enumerate(nums):
                another = target - num
                nums[index] = None
                if another in nums:
                    return [index,nums.index(another)]
            return None
</code></pre>
<h4 id="447-回旋镖的数量"><a href="#447-回旋镖的数量" class="headerlink" title="447. 回旋镖的数量"></a><a href="https://leetcode-cn.com/problems/number-of-boomerangs/" target="_blank" rel="noopener">447. 回旋镖的数量</a></h4><p>分别计算列表中的点与其他每一个点的距离放到dic这个字典里，以距离为键，出现的次数为值，再比较个数大于等于2的值有多少个，因为题目中说了要考虑到元组的顺序，所以A,B,C,D四个点以B为中心的话，会有6种回旋方式，ABC,CBA,ABD,DBA,CBD,DBC</p>
<pre><code class="lang-pythno">class Solution:
    def numberOfBoomerangs(self, points: List[List[int]]) -&gt; int:
        result = 0
        for m in points:
            dic = {}#每换一次中心点，dic会清空
            for j in points:
                distance = (m[0]-j[0])**2+(m[1]-j[1])**2
                if distance not in dic:
                    dic[distance]=1
                else:
                    dic[distance]+=1
            for val in dic.values():
                if val&gt;=2:
                    result+=val*(val-1)
        return result
</code></pre>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><h4 id="1456-定长子串中元音的最大数目"><a href="#1456-定长子串中元音的最大数目" class="headerlink" title="1456. 定长子串中元音的最大数目"></a><a href="https://leetcode-cn.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/" target="_blank" rel="noopener">1456. 定长子串中元音的最大数目</a></h4><p>看完<strong>slidingwindow.md</strong>后，发现其中有一句非常重要的提示性语句</p>
<blockquote>
<p>我们每移动向后移动一次大小为k的窗口，实际上变化的只有窗口两端的元素，也就是 新窗口元素和 = 旧窗口元素和 - 左边移除的元素 + 右边进来的元素，这样就可以写出如下$O(N)$时间复杂度的代码了</p>
</blockquote>
<p>所以思想就是先计算出来前k个字符串中含有元音字母的个数，将窗口慢慢往后移动，每次都判断s[i]和s[i+k-1]的元素是否是元音字母，因为在判断s[i]的时候已经将i+=1了，所以在下面需要进行判断时需要使用i+k-1，且在这里还需留意的一点是i+k-1判断的是<strong>移动后的最后一个字母</strong> ，在这里用num_tmp记录滑动窗口动态变化的元音字母的个数，返回的是这些tmp中的最大值num_ans</p>
<p>且在最下面用i+k-1&lt;length来限定不让窗口滑动出去</p>
<pre><code class="lang-python">class Solution:
    def maxVowels(self, s: str, k: int) -&gt; int:
        target = [&#39;a&#39;,&#39;e&#39;,&#39;i&#39;,&#39;o&#39;,&#39;u&#39;]
        length = len(s)
        num_tmp = 0
        for i in range(k):
            if s[i] in target:
                num_tmp+=1
        num_ans = num_tmp
        i=0
        while i&lt;(length-k):
            if s[i] in target :
                num_tmp -= 1
                i+=1
            elif s[i] not in target:
                i+=1
            if (i+k-1)&lt;length and s[i+k-1] in target:
                num_tmp +=1
            num_ans = max(num_ans,num_tmp)
        return num_ans
</code></pre>
<h4 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">438. 找到字符串中所有字母异位词</a></h4><p>看了评论中的提示知道需要用列表存储字母出现的次数，</p>
<p>且在这里自己的写法是在最开始进行一次判断，然后在for循环中每次滑动后再判断，可以防止数组越位</p>
<pre><code class="lang-python">class Solution:
    def findAnagrams(self, s: str, p: str) -&gt; List[int]:
        def is_same(num_p,num_s):
            if num_p!=num_s:
                return False
            else:
                return True
        #a的ascii为97
        #z的ascii为122
        num_p = [0]*26
        num_s = [0]*26
        for i in p:
            num_p[ord(i)-97]+=1
        tmp = s[:len(p)]
        for i in tmp:
            num_s[ord(i)-97]+=1
        ans = []
        j = len(p)
        if num_s == num_p:
                ans.append(0)
        for i in range(len(s)-len(p)):            
            num_s[ord(s[i])-97]-=1
            # print(num_s)
            num_s[ord(s[i+j])-97]+=1
            # print(num_s)
            if num_s == num_p:
                ans.append(i+1)
        return ans
</code></pre>
<h4 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">76. 最小覆盖子串</a></h4><p>看了官方题解和<strong><a href="https://github.com/acm4hn" target="_blank" rel="noopener">acm4hn</a></strong>大佬的评论题解半抄半写的结果：</p>
<p>思想是先移动有边界直到临时的字串包含了目标字符串的所有字母，且这里是通过cur_len来表明当前子串与目标子串“有多像”，当cur_len=len(t)的时候才是包含了所有目标串的字母（甚至会包括更多），然后才可以对左边界进行收缩。</p>
<p>在增加cur_len的条件设置的十分巧妙，只有当右边界的字符一定是收集目标子串的必备字符时，才对cur_len+1（<strong>必备</strong>指的是该字符一定在目标字符串中且当前字符串中该字符的数量小于目标字串的数量）</p>
<pre><code class="lang-python">class Solution:
    def minWindow(self, s: str, t: str) -&gt; str:
        if not t or not s or len(s)&lt; len(t):
            return &#39;&#39;
        ans = &#39;&#39;
        s_counter, t_counter = [0 for _ in range(58)], [0 for _ in range(58)]#这里可以不用上面大哥说的60，a~z+A~Z一共52改为字符，中间还夹杂着6个自他字符，详见http://ascii.diqibu.com/?a=91
        for c in t:
            t_counter[ord(c) - ord(&#39;A&#39;)] += 1
        l, r, cur_len, min_len = 0, 0, 0, float(&#39;inf&#39;)
        # 防止右边界越界
        while r &lt; len(s):
            s_counter[ord(s[r])-ord(&#39;A&#39;)]+=1
            if s[r] in t and s_counter[ord(s[r])-ord(&#39;A&#39;)]&lt;=t_counter[ord(s[r])-ord(&#39;A&#39;)]:
                cur_len+=1
            while l&lt;=r and cur_len==len(t):#说明找到了子串，再尝试把左边界收缩。目的是找到最小的
                if min_len&gt;r-l+1:
                    min_len = r-l+1
                    ans = s[l:r+1]
                s_counter[ord(s[l])-ord(&#39;A&#39;)]-=1
                if s[l] in t and s_counter[ord(s[l])-ord(&#39;A&#39;)]&lt;t_counter[ord(s[l])-ord(&#39;A&#39;)]:
                    cur_len-=1
                l+=1
            r+=1
        return ans
</code></pre>
<h4 id="30-串联所有单词的子串"><a href="#30-串联所有单词的子串" class="headerlink" title="30. 串联所有单词的子串"></a><a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/" target="_blank" rel="noopener">30. 串联所有单词的子串</a></h4><p>看了评论区的思路了解本题的思路与前一天的思路十分类似，不同之处在于本题是以等长单词为单位，需要以单词长度作为滑动单位，且最外层的for循环以0，length_one_word作为边界每次增加length_one_word确保不会漏解</p>
<p>下面注意在每次移动右指针需使得右指针指+length_one_word在总的字符串长度内，加上这个单词后再判断这个单词是否为我们真正需要的单词，如果是真正需要的，则让cur_len+=1，如果加上这个单词后多余了，还需将左指针右移每次移动都需要判断cur_len和num_words的关系，如果相等则加到ans中</p>
<pre><code class="lang-python">class Solution:
    def findSubstring(self, s: str, words: List[str]) -&gt; List[int]:
        from collections import Counter
        if not s or not words:return []
        length_one_word = len(words[0])
        length_total_string = len(s)
        num_words = len(words)
        counter_words = Counter(words)
        ans = []
        for i in range(0,length_one_word):
            left = i
            right = i
            cur_len = 0
            counter_tmp = Counter()
            while right+length_one_word&lt;=length_total_string:
                w = s[right:right+length_one_word]#有边界扩充的词
                right += length_one_word
                if w not in words:#进行特殊判断，看扩充的单词是否在目标单词中，如果不在就直接过了
                    left = right
                    counter_tmp.clear()
                    cur_len = 0
                else:#要扩充的单词在words里面
                    if counter_tmp[w]&lt;counter_words[w]:#且这个单词是缺少的单词
                        cur_len+=1
                        counter_tmp[w]+=1
                        if cur_len==num_words:
                            ans.append(left)               
                    else:#说明已经加上的这个单词是多余的
                        counter_tmp[w]+=1
                        while counter_tmp[w] &gt; counter_words[w]:
                            left_w = s[left:left+length_one_word]
                            left += length_one_word
                            if counter_tmp[left_w]&lt;=counter_words[left_w]:
                                cur_len -= 1
                            counter_tmp[left_w] -= 1
                            if cur_len==num_words:
                                ans.append(left)
        return ans
</code></pre>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><h4 id="268-缺失数字"><a href="#268-缺失数字" class="headerlink" title="268. 缺失数字"></a><a href="https://leetcode-cn.com/problems/missing-number/" target="_blank" rel="noopener">268. 缺失数字</a></h4><p>方法一：数学法</p>
<p>思路：计算1-n的和，减去数组和即为缺失数字</p>
<pre><code class="lang-python">class Solution:
    def missingNumber(self, nums: List[int]) -&gt; int:
        expect_sum = (len(nums))*(len(nums)+1)/2
        real_sum = sum(nums)
        return int(expect_sum-real_sum)
</code></pre>
<p>方法二：位运算</p>
<p>因为异或运算的规则是相同为0不同为1，所以可以使用这个方法将给的数组与1-n数组进行异或运算</p>
<pre><code class="lang-python">class Solution:
    def missingNumber(self, nums: List[int]) -&gt; int:
        length = len(nums)
        ans = 0
        for i in range(length):
            ans^=i
            ans^=nums[i]
        ans^=length
        return ans
</code></pre>
<h4 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78. 子集</a></h4><p>方法一：</p>
<p>回溯法：</p>
<h4 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. 全排列</a></h4><p>经典回溯：</p>
<pre><code class="lang-python">class Solution:
    def permute(self, nums: List[int]) -&gt; List[List[int]]:
        def dfs(sol,nums,used):
            if len(sol)==len(nums):
                ans.append(sol)
                return
            for i in range(len(nums)):
                if used[i]==1:
                    continue#相当于剪枝
                used[i]=1
                dfs(sol+[nums[i]],nums,used)
                used[i]=0
        ans = []
        used = [0 for i in range(len(nums))]
        dfs([],nums,used)
        return ans
</code></pre>
<p>上题注意点为在倒数第二行执行dfs([],nums,used)时，不能将[]改为ans，因为在执行递归的时候，会对ans进行改变也会改变影响“sol”因此在最外层的这个sol一定是[]空里表，千万不能与深层的语句操作有关联</p>
<h4 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a><a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">47. 全排列 II</a></h4><p>本题相比于46增加的限制是当used[i]==0的时候，说明当前用的这个元素没有被用过，且这个元素不是第一个元素，且当前元素与前一元素值相等且前一元素没被用到才被剪枝（这里注意第三个条件ued[i-1]==0的意思是前一个元素必须是没被用到才剪枝）在<a href="https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/中解释道改变条件为used[i]==1也可以通过，感觉那样不好理解" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/中解释道改变条件为used[i]==1也可以通过，感觉那样不好理解</a></p>
<p>可见下图</p>
<p><img src="/2020/08/05/lucifer-91/D:/rockblog\source\rockblog\source\_posts\lucifer-91\回溯.png" alt></p>
<pre><code class="lang-python">class Solution:
    def permuteUnique(self, nums: List[int]) -&gt; List[List[int]]:
        def dfs(sol,nums,used):
            if len(sol)==len(nums):
                ans.append(sol)
                return
            for i in range(len(nums)):
                if used[i]==1:
                    continue#相当于剪枝
                else:
                    if i&gt;0 and nums[i]==nums[i-1] and used[i-1]==0:
                        continue
                    used[i]=1
                    dfs(sol+[nums[i]],nums,used)
                    used[i]=0
        ans = []
        used = [0 for i in range(len(nums))]
        nums = sorted(nums)
        dfs([],nums,used)
        return ans
</code></pre>
<h4 id="78-子集-1"><a href="#78-子集-1" class="headerlink" title="78. 子集"></a><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78. 子集</a></h4><p>解法一：</p>
<p>回溯法：</p>
<pre><code class="lang-python">class Solution:
    def subsets(self, nums: List[int]) -&gt; List[List[int]]:
        def backtrack(ans_tmp,index,nums):
            if index==len(nums):
                ans.append(ans_tmp)
                return
            backtrack(ans_tmp+[nums[index]],index+1,nums)
            backtrack(ans_tmp,index+1,nums)
        ans = []
        backtrack([],0,nums)
        return ans
</code></pre>
<p>解法二：</p>
<p>位运算</p>
<p>备注：这里为什么需要使用到1 &lt;&lt; j &amp; i这个条件？</p>
<p>大佬的回答：</p>
<blockquote>
<p>以[1,2,3]为例，1&lt;&lt;j&amp;i用于判断1,2,3对应的二进制位是否存在于当前的i的二进制位中，这么说可能不清楚，你可以理解为[1,2]这个子集对应二进制数011，此时i为3，j在遍历时如果1&lt;&lt;j在i中对应位是1就把它加到临时的子集中，遍历完再放入结果集中</p>
</blockquote>
<p>补充：刚才说i为3，对应的是二进制是011，1&lt;&lt;j只有可能3种结果，001，010，100，这三个数分别与011做与运算，会使得当j=0,1时候的nums[j]加到子集中。</p>
<pre><code class="lang-python">class Solution:
    def subsets(self, nums: List[int]) -&gt; List[List[int]]:
        n = len(nums)
        res = []
        for i in range(2 ** n):
            temp = []
            for j in range(n):
                if 1 &lt;&lt; j &amp; i:
                    temp.append(nums[j])
            res.append(temp)
        return res
</code></pre>
<h4 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. 岛屿数量</a></h4><p>评论区带佬的感染思想:<br>只要是‘1’就看他周围四个方向的数字有没有‘1’如果有，就感染其为2，类似于dfs的思想</p>
<pre><code class="lang-python">class Solution:
    def numIslands(self, grid: List[List[str]]) -&gt; int:
        def infect(grid,i,j):
            if i&lt;0 or i&gt;=row or j&lt;0 or j&gt;=col or grid[i][j]!=&#39;1&#39;:
                return
            grid[i][j]= &#39;2&#39;
            infect(grid,i+1,j)
            infect(grid,i-1,j)
            infect(grid,i,j+1)
            infect(grid,i,j-1)
        ans = 0
        row = len(grid)
        col = len(grid[0]) if grid else 0
        for i in range(row):
            for j in range(col):
                if grid[i][j]==&#39;1&#39;:
                    infect(grid,i,j)
                    ans+=1
        return ans
</code></pre>
<h4 id="1254-统计封闭岛屿的数目"><a href="#1254-统计封闭岛屿的数目" class="headerlink" title="1254. 统计封闭岛屿的数目"></a><a href="https://leetcode-cn.com/problems/number-of-closed-islands/" target="_blank" rel="noopener">1254. 统计封闭岛屿的数目</a></h4><p>理解这道题目可以举个例子</p>
<p>1代表水，是你自己的地盘（没错，你就是海王）</p>
<p>0代表陆地，是你想要得到的地盘</p>
<p>可以假设每块单独被你包围的陆地有一个会走的金币，目的是算出给出的这个地图中，能拿到多少金币？</p>
<p>在执行程序的时候，可以假设这个金币只会上下左右逃跑，逃出边界的话，海王就拿不到这个金币了。</p>
<p>所以海王在找金币的时候，每碰到一个0都会把自己的海水带到这个陆地上，防止以后再做重复的查找工作</p>
<p>当一块金币的上下左右都逃不出去，才会将ans+=1</p>
<p>按顺序遍历所有的格子，之前遍历过的“0”陆地部分以及其相连的部分，会被海王染为1（感觉相当于提前就剪枝了的思想吧？）</p>
<p>下面的这个是通过的答案，代码是仿照<a href="https://leetcode-cn.com/u/stevewinger/" target="_blank" rel="noopener">stevewinger</a>写的python版本</p>
<pre><code class="lang-python">class Solution:
    def closedIsland(self, grid: List[List[int]]) -&gt; int:
        ans = 0
        row = len(grid)
        col = len(grid[0])
        def dfs(grid,i,j):
            if i&lt;0 or i&gt;=row or j &lt; 0 or j &gt;= col:#看是否会超出边界，超出的话，代表这个金币跑出去了，就返回False
                return False
            if grid[i][j]==1:
                #如果要被判断的这个单元是1，代表这块已经是水或者已经被标记了，金币跑到这也没辙，所以返回True
                return True
            grid[i][j]=1#将判断的这块0，标记为1
            #再判断这个单元上下左右四块有没有可能跑出去，如果都跑不出去，金币被逮到
            a = dfs(grid,i+1,j)
            b = dfs(grid,i-1,j)
            c = dfs(grid,i,j+1)
            d = dfs(grid,i,j-1)
            if a and b and c and d:#只有上下左右全是水，跑不出去
                return True
            else:
                return False
        for i in range(row):#每一行
            for j in range(col):#每一列
                if grid[i][j]==0:#只有要判断的这个为0，也就是说为陆地的时候，才会进行dfs
                    if dfs(grid,i,j):
                        ans+=1
        return ans
</code></pre>
<h4 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a><a href="https://leetcode-cn.com/problems/surrounded-regions/" target="_blank" rel="noopener">130. 被围绕的区域</a></h4><p>我写的老太太裹脚布：</p>
<p>用了两遍的dfs，</p>
<p>首先将外围的O相关的全改为B（dfs_border）</p>
<p>将内部的O全改为X(dfs_in),其实这里不需要用dfs，用遍历也可以，还省时间~</p>
<p>再将所有的B改回O</p>
<p>思路是看powcai神仙大佬的：</p>
<p><a href="https://leetcode-cn.com/problems/surrounded-regions/solution/dfs-bfs-bing-cha-ji-by-powcai/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/surrounded-regions/solution/dfs-bfs-bing-cha-ji-by-powcai/</a></p>
<p>一：</p>
<pre><code class="lang-python">class Solution:
    def solve(self, board: List[List[str]]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify board in-place instead.
        &quot;&quot;&quot;
        if board==[]:
            return 
        ans = 0
        row = len(board)
        col = len(board[0])
        def dfs_border(board,i,j):
            if i&lt;0 or i&gt;=row or j &lt; 0 or j &gt;= col:#看是否会超出边界，超出的话，代表这个金币跑出去了，就返回False
                return False
            if board[i][j]!=&#39;O&#39;:
                #如果要被判断的这个单元是1，代表这块已经是水或者已经被标记了，金币跑到这也没辙，所以返回True
                return True
            board[i][j]=&#39;B&#39;#将判断的这块0，标记为1
            #再判断这个单元上下左右四块有没有可能跑出去，如果都跑不出去，金币被逮到
            a = dfs_border(board,i+1,j)
            b = dfs_border(board,i-1,j)
            c = dfs_border(board,i,j+1)
            d = dfs_border(board,i,j-1)
            if a and b and c and d:#只有上下左右全是水，跑不出去
                return True
            else:
                return False

        #先将边界上与&#39;O&#39;相关的都变为特殊标记&#39;B&#39;
        for i in range(row):#
            if board[i][0] == &#39;O&#39;:#第一列的每一行
                dfs_border(board,i,0)
            if board[i][col-1] == &#39;O&#39;:#第一列的每一行
                dfs_border(board,i,col-1)
        for j in range(col):#
            if board[0][j] == &#39;O&#39;:#第一列的每一行
                dfs_border(board,0,j)
            if board[row-1][j] == &#39;O&#39;:#第一列的每一行
                dfs_border(board,row-1,j)
        #再将里面被围住的都从O改为X
        def dfs_in(board,i,j):
            if i&lt;0 or i&gt;=row or j &lt; 0 or j &gt;= col:#看是否会超出边界，超出的话，代表这个金币跑出去了，就返回False
                return False
            if board[i][j]==&#39;X&#39;:
                #如果要被判断的这个单元是1，代表这块已经是水或者已经被标记了，金币跑到这也没辙，所以返回True
                return True
            board[i][j]=&#39;X&#39;#将判断的这块0，标记为1
            #再判断这个单元上下左右四块有没有可能跑出去，如果都跑不出去，金币被逮到
            a = dfs_in(board,i+1,j)
            b = dfs_in(board,i-1,j)
            c = dfs_in(board,i,j+1)
            d = dfs_in(board,i,j-1)
            if a and b and c and d:#只有上下左右全是水，跑不出去
                board[i][j]=&#39;X&#39;
                return True
            else:
                return False
        for i in range(row):#每一行
            for j in range(col):#每一列
                if board[i][j]==&#39;O&#39;:#只有要判断的这个为0，也就是说为陆地的时候，才会进行dfs
                    if dfs_in(board,i,j):
                        ans+=1
        for i in range(row):
            for j in range(col):
                if board[i][j]!=&#39;X&#39;:
                    board[i][j]=&#39;O&#39;
</code></pre>
<p>二：</p>
<pre><code class="lang-python">class Solution:
    def solve(self, board: List[List[str]]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify board in-place instead.
        &quot;&quot;&quot;
        if board==[]:
            return 
        ans = 0
        row = len(board)
        col = len(board[0])
        def dfs_border(board,i,j):
            if i&lt;0 or i&gt;=row or j &lt; 0 or j &gt;= col:#看是否会超出边界，超出的话，代表这个金币跑出去了，就返回False
                return False
            if board[i][j]!=&#39;O&#39;:
                #如果要被判断的这个单元是1，代表这块已经是水或者已经被标记了，金币跑到这也没辙，所以返回True
                return True
            board[i][j]=&#39;B&#39;#将判断的这块0，标记为1
            #再判断这个单元上下左右四块有没有可能跑出去，如果都跑不出去，金币被逮到
            a = dfs_border(board,i+1,j)
            b = dfs_border(board,i-1,j)
            c = dfs_border(board,i,j+1)
            d = dfs_border(board,i,j-1)
            if a and b and c and d:#只有上下左右全是水，跑不出去
                return True
            else:
                return False

        #先将边界上与&#39;O&#39;相关的都变为特殊标记&#39;B&#39;
        for i in range(row):#
            if board[i][0] == &#39;O&#39;:#第一列的每一行
                dfs_border(board,i,0)
            if board[i][col-1] == &#39;O&#39;:#第一列的每一行
                dfs_border(board,i,col-1)
        for j in range(col):#
            if board[0][j] == &#39;O&#39;:#第一列的每一行
                dfs_border(board,0,j)
            if board[row-1][j] == &#39;O&#39;:#第一列的每一行
                dfs_border(board,row-1,j)
        for i in range(row):
            for j in range(col):
                if board[i][j]==&#39;O&#39;:
                    board[i][j]=&#39;X&#39;

        for i in range(row):
            for j in range(col):
                if board[i][j]!=&#39;X&#39;:
                    board[i][j]=&#39;O&#39;
</code></pre>
<h4 id="827-最大人工岛"><a href="#827-最大人工岛" class="headerlink" title="827. 最大人工岛"></a><a href="https://leetcode-cn.com/problems/making-a-large-island/" target="_blank" rel="noopener">827. 最大人工岛</a></h4><p>没过的暴力法：</p>
<pre><code class="lang-python">class Solution:
    def largestIsland(self, grid: List[List[int]]) -&gt; int:
        #第一种，暴力法，参考https://github.com/leetcode-pp/91alg-1/issues/104#issuecomment-674759558
        #思路是对于每一块海洋都看其周围的陆地面积最大能联通多少，取最大值
        directions = [(0,1),[0,-1],[1,0],[-1,0]]
        def dfs(grid,i,j):
            stack = [(i,j)]
            area = {(i,j)}
            while stack:
                i,j = stack.pop()
                for direction_x,direction_y in directions:
                    tmp_x = i+direction_x
                    tmp_y = j+direction_y
                    if 0&lt;=tmp_x&lt;row and 0&lt;=tmp_y&lt;col and (tmp_x,tmp_y) not in area and grid[tmp_x][tmp_y]==1:
                        stack.append((tmp_x,tmp_y))
                        area.add((tmp_x,tmp_y))
                    self.ans = max(self.ans,len(area))
        self.ans = 0
        flag = False
        row = len(grid)
        col = len(grid[0])
        for i in range(row):
            for j in range(col):
                if grid[i][j]==0:
                    dfs(grid,i,j)
                    flag = True
        return self.ans if flag else row*col#意思是flag如果一直为False说明根本没有碰到海洋，所以就返回整个面积
</code></pre>
<p>方法二：</p>
<pre><code class="lang-python">class Solution:
    def largestIsland(self, grid: List[List[int]]) -&gt; int:
        #第二种，先用dfs将所有的原先就连着的岛屿按照颜色进行染色
        #然后把图中的每一块海水都变为陆地，看与其连着的四周是否有其他颜色的陆地，再加起来

        def dfs(i,j,color):
            if 0&lt;=i&lt;row and 0&lt;=j&lt;col and grid[i][j]==1:
                grid[i][j]=color
                return 1+dfs(i+1,j,color)+dfs(i-1,j,color)+dfs(i,j+1,color)+dfs(i,j-1,color)
            else:
                return 0
        row = len(grid)
        col = len(grid[0])
        color_dic = {}
        color = 2
        ans = 0
        for i in range(row):
            for j in range(col):
                if grid[i][j]==1:
                    color_dic[color] = dfs(i,j,color)
                    color+=1
        color_dic[0] = 0
        ans = max(color_dic.values())
        for i in range(row):
            for j in range(col):
                if grid[i][j]==0:
                    color_set = set()
                    for r,c in [(i + 1, j), (i, j + 1), (i - 1, j), (i, j - 1)]:
                        if 0&lt;=r&lt;row and 0&lt;=c&lt;col:
                            if grid[r][c]&gt;1:
                                color_set.add(grid[r][c])
                    ans = max(ans,1+sum(color_dic[tmp] for tmp in color_set))
        return ans
</code></pre>
<h4 id="89-格雷编码"><a href="#89-格雷编码" class="headerlink" title="89. 格雷编码"></a><a href="https://leetcode-cn.com/problems/gray-code/" target="_blank" rel="noopener">89. 格雷编码</a></h4><p>找到规律：</p>
<p>一位：</p>
<p>0</p>
<p>两位：</p>
<p>00</p>
<p>01</p>
<p>11</p>
<p>10</p>
<p>三位：</p>
<p>00        000</p>
<p>01        001</p>
<p>11        011</p>
<p>10  —&gt; 010</p>
<p>10        110</p>
<p>11        111</p>
<p>01        101</p>
<p>00        100</p>
<p>三位的生成过程：</p>
<p>按照二位的顺着写一遍，逆着写一遍，再在逆序的最前面位上填上1，因为只是在其后面添加，append即可</p>
<pre><code class="lang-python">class Solution:
    def grayCode(self, n: int) -&gt; List[int]:
        ans = [0]
        head = 1
        for i in range(n):
            for j in range(len(ans)-1,-1,-1):
                ans.append(head+ans[j])
            head&lt;&lt;=1
        return ans
</code></pre>
<h4 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a></h4><p>动态规划解法</p>
<pre><code class="lang-python">class Solution:
    def uniquePaths(self, m: int, n: int) -&gt; int:
        dp = [[ 0 for _ in range(n)] for _ in range(m)]
        dp[0][0] = 0
        for i in range(m):
            dp[i][0] = 1
        for j in range(n):
            dp[0][j] = 1
        for i in range(1,m):
            for j in range(1,n):
                dp[i][j] = dp[i-1][j]+dp[i][j-1]
        return dp[m-1][n-1]
</code></pre>
<p>阶乘：</p>
<pre><code class="lang-python">class Solution:
    def uniquePaths(self, m: int, n: int) -&gt; int:
        def helper(i):
            tmp_ans = 1
            for i in range(i,0,-1):
                tmp_ans*=i
            return tmp_ans
        total_step = m+n-2
        down = m-1
        right = n-1
        return int(helper(total_step)/helper(down)/helper(right))
</code></pre>
<script type="math/tex; mode=display">
C_{n}^{m}=\frac{P_{n}^{m}}{P_{m}}=\frac{n !}{m !(n-m) !}, C_{n}^{0}=1</script><h4 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a><a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">63. 不同路径 II</a></h4><pre><code class="lang-python">class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int:
        # obstacleGrid = [[0,0],[1,1],[0,0]]
        row = len(obstacleGrid)
        col = len(obstacleGrid[0])
        if obstacleGrid[row-1][col-1]==1 or obstacleGrid[0][0]==1:
            return 0
        dp = [[0 for _ in range(col)] for _ in range(row)]
        for i in range(row):
            if obstacleGrid[i][0]==0:
                dp[i][0] = 1
            if obstacleGrid[i][0]==1:
                dp[i][0] = 0
                break
        for i in range(col):
            if obstacleGrid[0][i]==0:
                dp[0][i] = 1
            if obstacleGrid[0][i]==1:
                dp[0][i] = 0
                break
        for i in range(1,row):
            for j in range(1,col):
                if obstacleGrid[i][j] == 0:
                    dp[i][j] = dp[i-1][j]+dp[i][j-1]
        #最后一列 和最后一行
        return dp[row-1][col-1]
</code></pre>
<h4 id="980-不同路径-III"><a href="#980-不同路径-III" class="headerlink" title="980. 不同路径 III"></a><a href="https://leetcode-cn.com/problems/unique-paths-iii/" target="_blank" rel="noopener">980. 不同路径 III</a></h4><p>思路是</p>
<p>1.先遍历一遍将起始点找到，顺道算出总共需要走的步数，类似于官方题解的“todo”也就是还需要走的步数</p>
<p>2.使用dfs从起始点遍历，先来个特殊判断，如果这个x，y超过这个方框或者当前判断的点是-1（也就是代表这个点已经判断过）则返回0</p>
<p>3.如果这个点是2，且num_step为0，代表已经到最后的一步了，返回1，否则返回0（代表这条路不通）</p>
<p>4.回溯：把遍历过的点标志为-1从该点开始向四个方向进行dfs，每次都将num_step-1，将四个方向的返回值加起来（每一步里面都会再以其为中心向四个方向进行探索），总之当num_step为0且grid[x][y]==2的时候就完事，最后返回初始点的四个方向的和。</p>
<pre><code class="lang-python">class Solution:
    def uniquePathsIII(self, grid: List[List[int]]) -&gt; int:
        ans = 0
        row,col = len(grid),len(grid[0])
        start_x = start_y = 0
        num_step = 1
        def dfs(x,y,num_step,grid):
            if x&lt;0 or x&gt;=row or y&lt;0 or y&gt;= col or grid[x][y]==-1:
                return 0
            if grid[x][y]==2:
                if num_step==0:
                    return 1
                else:
                    return 0
            grid[x][y]=-1
            ans_tmp = 0
            ans_tmp+=dfs(x-1,y,num_step-1,grid)
            ans_tmp+=dfs(x+1,y,num_step-1,grid)
            ans_tmp+=dfs(x,y-1,num_step-1,grid)
            ans_tmp+=dfs(x,y+1,num_step-1,grid)
            grid[x][y]=0
            return ans_tmp
        for i in range(row):
            for j in range(col):
                if grid[i][j]==1:
                    start_x = i#找到初始位置
                    start_y = j
                    continue
                if grid[i][j]==0:
                    num_step+=1
        return dfs(start_x,start_y,num_step,grid)
</code></pre>
<h4 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a></h4><p>自底向上的思路是对于每个钱数，每种硬币都有加入或者不加入两种选择，我们要的是这两种选择中最少硬币数量，自底向上算到dp[amount]即为答案</p>
<pre><code class="lang-python">class Solution:
    def coinChange(self, coins: List[int], amount: int) -&gt; int:
        dp = [float(&#39;inf&#39;)]*(amount+1)
        dp[0] = 0
        for coin in coins:
            for x in range(coin,amount+1):
                dp[x] = min(dp[x],dp[x-coin]+1)
        return dp[amount] if dp[amount]!=float(&#39;inf&#39;) else -1
</code></pre>
<h4 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a><a href="https://leetcode-cn.com/problems/coin-change-2/" target="_blank" rel="noopener">518. 零钱兑换 II</a></h4><p>dp[i][j]的定义为</p>
<blockquote>
<p>若只使用前 <code>i</code> 个物品，当背包容量为 <code>j</code> 时，有 <code>dp[i][j]</code> 种方法可以装满背包。</p>
<p><strong>如果你不把这第</strong> <strong><code>i</code></strong> <strong>个物品装入背包</strong>，也就是说你不使用 <code>coins[i]</code> 这个面值的硬币，那么凑出面额 <code>j</code> 的方法数 <code>dp[i][j]</code> 应该等于 <code>dp[i-1][j]</code>，继承之前的结果。</p>
<p><strong>如果你把这第</strong> <strong><code>i</code></strong> <strong>个物品装入了背包</strong>，也就是说你使用 <code>coins[i]</code> 这个面值的硬币，那么 <code>dp[i][j]</code> 应该等于 <code>dp[i][j-coins[i-1]]</code>。</p>
</blockquote>
<pre><code class="lang-python">class Solution:
    def change(self, amount: int, coins: List[int]) -&gt; int:
        dp = [[1]+[0]*amount for _ in range(len(coins)+1)]#1表示无论怎么凑，和为0的方法只有一个就是什么也不做
        n = len(coins)
        for i in range(1,n+1):
            for j in range(1,amount+1):
                if j&gt;=coins[i-1]:
                    dp[i][j] = dp[i-1][j]+dp[i][j-coins[i-1]]
                else:
                    dp[i][j] = dp[i-1][j]
        return dp[-1][-1]
</code></pre>
<h4 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">416. 分割等和子集</a></h4><p>本题是经典动态规划（01背包）问题，是否能将列表里的元素平均分为两组，且每组的数字和相等</p>
<p>选自评论区lu_的题解<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/0-1-bei-bao-wen-ti-xiang-jie-zhen-dui-ben-ti-de-yo/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/0-1-bei-bao-wen-ti-xiang-jie-zhen-dui-ben-ti-de-yo/</a></p>
<p>其中第一种方法的时间复杂度为O(NC),空间复杂度为O(NC)</p>
<p>第二种方法的时间复杂度为O(NC),空间复杂度为O(C) 将二维数组变为一维数组</p>
<blockquote>
<p>状态定义：<code>dp[i][j]</code>表示从数组的 <code>[0, i]</code> 这个子区间内挑选一些正整数，每个数只能用一次，使得这些数的和<strong>恰好等于</strong> <code>j</code>。</p>
</blockquote>
<pre><code class="lang-python">class Solution:
    def canPartition(self, nums: List[int]) -&gt; bool:
        #动态规划 填表格true/false dp[i][j]=dp[i-1][j] or dp[i-1][j-nums[i]] 优化1-提前结束
        if sum(nums)%2!=0:
            return False
        dp=[[False]*(sum(nums)//2+1) for i in range(len(nums))]
        for j in range(sum(nums)//2+1):
            if nums[0]==j:
                dp[0][j]=True
        for i in range(1,len(nums)):
            for j in range(1,sum(nums)//2+1):
                if j-nums[i]&gt;=0:
                    dp[i][j]=dp[i-1][j] or dp[i-1][j-nums[i]]
                else:
                    dp[i][j]=dp[i-1][j]
            if dp[i][-1]==True: #
                return True
        return dp[-1][-1]


    def canPartition(self, nums: List[int]) -&gt; bool:
            #动态规划 填表格true/false dp[i][j]=dp[i-1][j] or dp[i-1][j-nums[i]] 优化2-二维降一维
        if sum(nums)%2!=0:
            return False
        dp=[False]*(sum(nums)//2+1)
        i=0
        while i&lt;len(nums):
            if i==0:
                for j in range(sum(nums)//2+1):
                    if nums[i]==j:
                        dp[j]=True
            else:
                for j in range(sum(nums)//2,0,-1): #从前往后依次填表不对,后面的j的结果不在时建立在上一层的T/F基础上，而变成建立在同层的T/F的基础上了 应该从后往前依次填表
                    if j-nums[i]&gt;=0:
                        dp[j]=dp[j] or dp[j-nums[i]]
                    else:
                        continue
            i+=1
        return dp[-1]
</code></pre>
<p>按照算法画出表格发现，如果不设置第一列为TRUE也可以完整走完算法，且原解析说的很精妙的一处是</p>
<blockquote>
<p><strong>当前行总是参考了它上面一行 “头顶上” 那个位置和“左上角”某个位置的值</strong>。</p>
</blockquote>
<p><img src="/2020/08/05/lucifer-91/动态规划/1.png" alt></p>
<h4 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a><a href="https://leetcode-cn.com/problems/target-sum/" target="_blank" rel="noopener">494. 目标和</a></h4><p>可以结合<a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/targetsum才能看明白是怎么从二维数组变为一维数组" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/targetsum才能看明白是怎么从二维数组变为一维数组</a></p>
<p>最重要的点是在遍历第二层循环的时候需要从后向前遍历，相当于把P减少到0，这样才不会改变数组</p>
<p>P = (sum(nums) + S) // 2是怎么来的？</p>
<blockquote>
<p>因为原题目可以转为正数集合的和与负数集合的和相加的问题</p>
<p>sum(P) - sum(N) = target</p>
<p>（两边同时加上sum(P)+sum(N)）</p>
<p>sum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N)</p>
<p>(因为 sum(P) + sum(N) = sum(nums))<br>2 * sum(P) = target + sum(nums)</p>
<p>作者：qsctech-sange<br>链接：<a href="https://leetcode-cn.com/problems/target-sum/solution/python-dfs-xiang-jie-by-jimmy00745/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/target-sum/solution/python-dfs-xiang-jie-by-jimmy00745/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<pre><code class="lang-python">class Solution:
    def findTargetSumWays(self, nums: List[int], S: int) -&gt; int:
        if sum(nums) &lt; S or (sum(nums) + S) % 2 == 1: return 0
        P = (sum(nums) + S) // 2
        dp = [1] + [0 for _ in range(P)]
        for num in nums:
            for j in range(P,num-1,-1):dp[j] += dp[j - num]
        return dp[P]

作者：qsctech-sange
链接：https://leetcode-cn.com/problems/target-sum/solution/python-dfs-xiang-jie-by-jimmy00745/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<h4 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474. 一和零"></a><a href="https://leetcode-cn.com/problems/ones-and-zeroes/" target="_blank" rel="noopener">474. 一和零</a></h4><p>本题为经典的背包问题，与之前做的不同点在于，本题需要考虑有两种变量分别为0和1，根据<a href="https://leetcode-cn.com/problems/ones-and-zeroes/solution/01bei-bao-zi-ding-xiang-xia-he-zi-di-xiang-shang-b/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ones-and-zeroes/solution/01bei-bao-zi-ding-xiang-xia-he-zi-di-xiang-shang-b/</a> 大神写的解答，在其基础上将第一维优化掉了，注意点是在优化时需要将数组从后往前遍历。</p>
<pre><code class="lang-python">class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -&gt; int:
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        for str_tmp in strs:
            num_0 = str_tmp.count(&#39;0&#39;)
            num_1 = str_tmp.count(&#39;1&#39;)
            for i in range(m,-1,-1):
                for j in range(n,-1,-1):
                    dp[i][j] = dp[i][j]
                    if i&gt;=num_0 and j&gt;=num_1 and dp[i][j] &lt; dp[i-num_0][j-num_1]+1:
                        dp[i][j] = dp[i-num_0][j-num_1]+1
        return dp[-1][-1]
</code></pre>
<h4 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/" target="_blank" rel="noopener">746. 使用最小花费爬楼梯</a></h4><p>状态转移方程为dp[i] = min(dp[i-1],dp[i-2])+cost[i]</p>
<pre><code class="lang-python">class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -&gt; int:
        dp = [0]*len(cost)
        dp[0] = cost[0]
        dp[1] = cost[1]
        for i in range(2,len(cost)):
            dp[i] = min(dp[i-1],dp[i-2])+cost[i]
        return min(dp[-1],dp[-2])
</code></pre>
<p>变形题目：</p>
<pre><code class="lang-python">class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -&gt; int:
        if len(cost)&lt;=2:
            return dp[-1]
        dp = [0]*len(cost)
        dp[0] = cost[0]
        dp[1] = cost[1]
        for i in range(2,len(cost)):
            dp[i] = min(dp[i-1],dp[i-2])+cost[i]
        return dp[-1]
</code></pre>
<p>看了评论区神仙大佬<strong><a href="https://github.com/Liu821218213" target="_blank" rel="noopener">Liu821218213</a></strong> 了解到主要区别是变形的题目有个硬性要求是第n阶的台阶必须要走！</p>
<p>且没规定太结束一定是大于2的</p>
<h4 id="790-多米诺和托米诺平铺"><a href="#790-多米诺和托米诺平铺" class="headerlink" title="790. 多米诺和托米诺平铺"></a><a href="https://leetcode-cn.com/problems/domino-and-tromino-tiling/" target="_blank" rel="noopener">790. 多米诺和托米诺平铺</a></h4><p>如果只有多米诺的砖块，递推公式则是<strong>dp[i] = dp[i-1] + dp[i-2]</strong>,详细的图可以看<a href="https://leetcode-cn.com/problems/domino-and-tromino-tiling/solution/zong-jie-yi-xia-da-lao-de-dpsi-lu-by-huan-shi-cai-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/domino-and-tromino-tiling/solution/zong-jie-yi-xia-da-lao-de-dpsi-lu-by-huan-shi-cai-/</a></p>
<p>需要注意的是在这种情况下dp[i]与dp[i-2]的关系就只算</p>
<p><img src="/2020/08/05/lucifer-91/D:/rockblog\source\rockblog\source\_posts\lucifer-91\image-20200831100450101.png" alt></p>
<p>而下图的这种添加方法算作在dp[i-1]基础上进行变化的</p>
<p><img src="/2020/08/05/lucifer-91/D:/rockblog\source\rockblog\source\_posts\lucifer-91\image-20200831100540832.png" alt></p>
<p>当只有托米诺的砖块后，递推公式为<strong>dp[i]=2*dp[i-3]</strong></p>
<p>如果有多米诺和托米诺两种砖块，则是两种递推公式的结合版本：</p>
<p>按照我的理解，两个dp列表中dp代表的是只用多米诺，dp2是只用托米诺砖块，结合出来为</p>
<p>dp[i] = dp[i-1] + dp[i-2] + 2dp2[i-2]</p>
<p>而dp2[i] = dp[i-1] + dp2[i-1]</p>
<p>（感觉有点像找规律的题）递推公式为</p>
<blockquote>
<p>dp[i]<br>= dp[i-1] + dp[i-2] + 2dp2[i-2]<br>= dp[i-1] + dp[i-2] + 2(dp[i-3] + dp2[i-3])<br>= 2dp[i-1] + dp[i-2] + 2(dp[i-3] + dp2[i-3]) - dp[i-1]<br>= 2dp[i-1] + dp[i-2] + 2(dp[i-3] + dp2[i-3]) - dp[i-2] - dp[i-3] - 2dp2[i-3]<br>= 2dp[i-1] + 2(dp[i-3] + dp2[i-3]) - 2dp2[i-3] - dp[i-3]<br>= 2dp[i-1] + 2(dp[i-3] + dp2[i-3]) - 2dp2[i-3] - dp[i-3]<br>= 2dp[i-1] + 2(dp[i-3] + dp2[i-3]) - 2dp2[i-3] - dp[i-3] （重要的地方写三遍？）<br>= 2dp[i-1] + dp[i-3]</p>
<p>作者：huan-shi-cai-zhao-shu-fu<br>链接：<a href="https://leetcode-cn.com/problems/domino-and-tromino-tiling/solution/zong-jie-yi-xia-da-lao-de-dpsi-lu-by-huan-shi-cai-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/domino-and-tromino-tiling/solution/zong-jie-yi-xia-da-lao-de-dpsi-lu-by-huan-shi-cai-/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<pre><code class="lang-python">class Solution:
    def numTilings(self, N: int) -&gt; int:
        mod = 1000000007
        dp = [0]*(N+3)
        dp[0] = 1
        dp[1] = 1
        dp[2] = 2
        dp[3] = 5
        for i in range(4,N+1):
            dp[i] = (2*(dp[i-1] % mod) % mod + dp[i-3] % mod) % mod
        return dp[N]%mod
</code></pre>
<h4 id="935-骑士拨号器"><a href="#935-骑士拨号器" class="headerlink" title="935. 骑士拨号器"></a><a href="https://leetcode-cn.com/problems/knight-dialer/" target="_blank" rel="noopener">935. 骑士拨号器</a></h4><p>需要注意的点是题目中的要求是 N-1 步，所以range里面是（n-1）</p>
<pre><code class="lang-python">class Solution:
    def knightDialer(self, n: int) -&gt; int:
        if n==1:
            return 10
        ans = [1,1,1,1]
        for _ in range(n-1):
            ans = [ans[1]+ans[2],2*ans[0],2*ans[0]+ans[3],2*ans[2]]
        return (4*ans[0]+2*ans[1]+2*ans[2]+ans[3])%1000000007
</code></pre>
<h4 id="1458-两个子序列的最大点积"><a href="#1458-两个子序列的最大点积" class="headerlink" title="1458. 两个子序列的最大点积"></a><a href="https://leetcode-cn.com/problems/max-dot-product-of-two-subsequences/" target="_blank" rel="noopener">1458. 两个子序列的最大点积</a></h4><p>一共分为四种选项：</p>
<ul>
<li>只要第i个数和第j个数的乘积（这种情况考虑的是之前的乘积为负数，没必要加上之前的数）</li>
<li>只要第j个数，不要第i个数</li>
<li>只要第i个数，不要第j个数</li>
<li>要第i个数和第j个数的乘积并且加上前面的最大值</li>
</ul>
<pre><code class="lang-python">class Solution:
    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -&gt; int:
        inf = float(&#39;-inf&#39;)
        m = len(nums1)
        n = len(nums2)
        dp = [[inf]*(n+1) for _ in range(m+1)]
        for i in range(1,m+1):
            for j in range(1,n+1):
                dp[i][j] = max(nums1[i-1]*nums2[j-1],dp[i-1][j],dp[i][j-1],nums1[i-1]*nums2[j-1]+dp[i-1][j-1])
        return dp[m][n]
</code></pre>
<h4 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">96. 不同的二叉搜索树</a></h4><p>题解是仿照<strong><a href="https://github.com/Liu821218213" target="_blank" rel="noopener">Liu821218213</a></strong>大佬写的，最开始有一点不明白，为什么j的范围是从1到i的闭区间（也就是range(1,i+1)）后来明白了 只需要考虑到左右两支子树需要从0到i-1即可，也就是说当计算dp[3]的时候，排出去中间的根节点还有两个节点是可用的，分别就是左0右2，左1又1，左2右0，然后将这三种情况加起来即可</p>
<pre><code class="lang-python">class Solution:
    def numTrees(self, n: int) -&gt; int:
        dp = [0]*(n+1)
        dp[0] = dp[1] = 1#base case是dp[0]和dp[1]都是1,意思是0个节点和1个节点都只有一种排序方法
        for i in range(2,n+1):#i从2开始一直到n
            for j in range(0,i):#j的范围需要从1开始移植到i
                dp[i] += dp[j]*dp[i-j-1]
        return dp[n]
</code></pre>
<h4 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23. 合并K个升序链表"></a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">23. 合并K个升序链表</a></h4><p>分治的思想是先把这些列表们进行拆分（除以2），直到每一块的大小都是1再将这些大小为1的列表们进行合并</p>
<pre><code class="lang-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:
        if not lists:
            return None
        n = len(lists)
        def devide_merge(left,right):
            if left&gt;right:
                return
            if left==right:
                return lists[left]#这种情况就是块的大小为1，下一步就是需要合并了
            mid = (left+right)//2
            l1 = devide_merge(left,mid)
            l2 = devide_merge(mid+1,right)
            return mergeTwoLists(l1,l2)
        def mergeTwoLists(l1,l2):
            if not l1 or not l2:
                return l1 or l2
            if l1.val&lt;l2.val:
                l1.next = mergeTwoLists(l1.next,l2)
                return l1
            else:
                l2.next = mergeTwoLists(l1,l2.next)
                return l2
        return devide_merge(0,n-1)
</code></pre>
<p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/duo-tu-yan-shi-23-he-bing-kge-pai-xu-lian-biao-by-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/duo-tu-yan-shi-23-he-bing-kge-pai-xu-lian-biao-by-/</a> 题解中还有一种非常暴力的解法，也是一一合并，只不过思路是分别将第二个列表到最后一个列表都合并到第一个列表中。</p>
<pre><code class="lang-python">class Solution(object):
    def mergeKLists(self, lists):
        if not lists:
            return None
        n = len(lists)
        res = lists[0]
        # 合并两个有序链表
        def merge(a,b):
            if not (a and b):
                return a if a else b
            if a.val&lt;=b.val:
                a.next = merge(a.next,b)
                return a
            else:
                b.next = merge(a,b.next)
                return b
        # 将lists[0]作为最终合并的链表，然后将list[0]和lists[1]合并成lists[0-1]
        # 再将lists[0-1]和lists[2]合并，如此反复最终lists[0]就是最终结果
        for i in xrange(1,n):
            res = merge(res,lists[i])
        return res

作者：wang_ni_ma
链接：https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/duo-tu-yan-shi-23-he-bing-kge-pai-xu-lian-biao-by-/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<p>他们的区别为：暴力解法相当于插入排序，一一合并一共需要合并1+2+…+k-1次，每次合并需要合并N/k个节点，所以一共就是 (1+k-1) <em> N/k /2，也就是O(N</em>k)</p>
<p>而分治算法像是归并排序</p>
<blockquote>
<p>第一轮合并之后，链表总数就变成了<code>k/2</code>个(因为是两两合并，所以两个就变成一个了)<br>第二轮之后链表总数变成了<code>k/4</code>个<br>第三轮之后链表总数变成了<code>k/8</code>个<br>所以这是以对数时间复杂度降低的过程，而每轮都需要遍历<code>N</code>个节点，所以总时间负复杂度就是<code>O(Nlogk)</code></p>
<p>—<a href="https://leetcode-cn.com/u/wang_ni_ma/" target="_blank" rel="noopener">王尼玛</a></p>
</blockquote>
<h4 id="881-救生艇"><a href="#881-救生艇" class="headerlink" title="881. 救生艇"></a><a href="https://leetcode-cn.com/problems/boats-to-save-people/" target="_blank" rel="noopener">881. 救生艇</a></h4><p>思路是将所有人的体重进行排序，设置双指针，体重较轻的左指针和体重较大的右指针合并在一起，如果其和大于limit就不能带上左指针，只将大体重放入救生艇，且右指针减一，如果小于等于limit就可以将二人全放入救生艇中</p>
<pre><code class="lang-python">class Solution:
    def numRescueBoats(self, people: List[int], limit: int) -&gt; int:
        people.sort()
        ans = 0
        l = 0
        r = len(people)-1
        while l&lt;=r:
            if l==r:
                return ans+1
            if people[l]+people[r]&gt;limit:
                ans+=1
                r-=1
            if people[l]+people[r]&lt;=limit:
                ans+=1
                r-=1
                l+=1
        return ans
</code></pre>
<h4 id="765-情侣牵手"><a href="#765-情侣牵手" class="headerlink" title="765. 情侣牵手"></a><a href="https://leetcode-cn.com/problems/couples-holding-hands/" target="_blank" rel="noopener">765. 情侣牵手</a></h4><p>1.如果不用异或操作可以用如下方法判断</p>
<pre><code class="lang-python">class Solution:
    def minSwapsCouples(self, row: List[int]) -&gt; int:
        ans = 0
        for i in range(0,len(row),2):
            x = row[i]
            if (x%2==0 and x+1==row[i+1]) or (x%2==1 and x-1==row[i+1]):
                continue
            ans+=1
            for j in range(i+1,len(row)):
                if (x%2==0 and x+1==row[j]) or (x%2==1 and x-1==row[j]):
                    row[i+1],row[j] = row[j],row[i+1]
                    break
            print(row)
        return ans
</code></pre>
<p>2.异或 出自官方题解</p>
<pre><code class="lang-python">class Solution(object):
    def minSwapsCouples(self, row):
        ans = 0
        for i in xrange(0, len(row), 2):
            x = row[i]
            if row[i+1] == x^1: continue
            ans += 1
            for j in xrange(i+1, len(row)):
                if row[j] == x^1:
                    row[i+1], row[j] = row[j], row[i+1]
                    break
        return ans

作者：LeetCode
链接：https://leetcode-cn.com/problems/couples-holding-hands/solution/qing-lu-qian-shou-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<h4 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">136. 只出现一次的数字</a></h4><p>第一种解法比较笨，把全部数字都放到字典里面，然后找到值为1的键</p>
<pre><code class="lang-python">class Solution:
    def singleNumber(self, nums: List[int]) -&gt; int:
        ans = {}
        for i in nums:
            if i in ans:
                ans[i]+=1
            else:
                ans[i]=1
        for k,v in ans.items():
            if v==1:
                return k
</code></pre>
<p>第二种解法是将全部的数字进行异或，利用的原理是相同数字异或肯定得0，最后剩下的数字就是那个只出现一次的数字</p>
<pre><code class="lang-python">class Solution:
    def singleNumber(self, nums: List[int]) -&gt; int:
        ans = 0
        for i in nums:
            ans^=i
        return ans
</code></pre>
<h4 id="137-只出现一次的数字-II"><a href="#137-只出现一次的数字-II" class="headerlink" title="137. 只出现一次的数字 II"></a><a href="https://leetcode-cn.com/problems/single-number-ii/" target="_blank" rel="noopener">137. 只出现一次的数字 II</a></h4><p>第一种方法同136上一题按照值为1来找键</p>
<p>第二种方法：</p>
<pre><code class="lang-python">class Solution:
    def singleNumber(self, nums: List[int]) -&gt; int:
        ans = 0
        for i in range(32):
            cnt = 0
            bit = 1&lt;&lt;i
            for num in nums:
                if num&amp;bit!=0:
                    cnt+=1
            if cnt%3!=0:
                ans|=bit
        return ans -2**32 if ans&gt;2**31-1 else ans
</code></pre>
<h4 id="645-错误的集合"><a href="#645-错误的集合" class="headerlink" title="645. 错误的集合"></a><a href="https://leetcode-cn.com/problems/set-mismatch/" target="_blank" rel="noopener">645. 错误的集合</a></h4><p>思路是算出给定的nums之和，nums变为集合后的总和，正常原版nums的总和，再互相做减法得到重复的数字和缺失的数字。</p>
<pre><code class="lang-python">class Solution:
    def findErrorNums(self, nums: List[int]) -&gt; List[int]:
        sum_nums = sum(nums)
        sum_set_nums = sum(set(nums))
        sum_ori_nums = sum([i for i in range(1,len(nums)+1)])
        return [sum_nums-sum_set_nums,sum_ori_nums-sum_set_nums]
</code></pre>
<p>位运算的思路大概为，将nums的每一个数字进行异或运算，最后得到acc，将acc转换为二进制再求得长度再-3得到n，再在nums中的所有数都遍历一遍，如果该数字右移n位与1做与运算，结果为0的分为一组，结果位1的分为一组，在这里用到的知识点是题中的除去要的两个只出现一次的数字外，其他数字都出现2次，所以出现2次的经过异或运算后为0，而n = len(bin(acc))-3 对异或后的结果进行额外操作可以得到这两个出现一次的数字的主要区别的位数节点，通过这个节点再分为两个数返回即可</p>
<pre><code class="lang-python">class Solution:
    def singleNumber(self, nums: List[int]) -&gt; List[int]:
        acc = 0
        for i in nums:
            acc ^=i
        n = len(bin(acc))-3
        a,b=0,0
        for i in nums:
            if i&gt;&gt;n&amp;1:
                a^=i
            else:
                b^=i
        return b,a
</code></pre>
<h4 id="面试题-04-01-节点间通路"><a href="#面试题-04-01-节点间通路" class="headerlink" title="面试题 04.01. 节点间通路"></a><a href="https://leetcode-cn.com/problems/route-between-nodes-lcci/" target="_blank" rel="noopener">面试题 04.01. 节点间通路</a></h4><p>思路为将给定的graph的二维列表转化为{0: [1, 2], 1: [2]} 这种以起点为键，以可直接到达的终点为值的字典形式，然后遍历给定的起点能到达的终点，如果有就返回True，没有的话就检查中间节点到重点是否可以到达，注意其中用isVisited的标识位标明如果这个节点访问过则直接返回False</p>
<pre><code class="lang-python">class Solution:
    def findWhetherExistsPath(self, n: int, graph: List[List[int]], start: int, target: int) -&gt; bool:
        self.dic = {}
        self.isVisted = [False for _ in range(n)]
        for nodes in graph:
            from_node = nodes[0]
            to_node = nodes[1]
            if from_node not in self.dic:
                self.dic[from_node] = [to_node]
            elif to_node not in self.dic[from_node]:
                self.dic[from_node].append(to_node)
        return self.helper(start,target)
    def helper(self,start,end):
        if start not in self.dic:
            return False
        if self.isVisted[start]:
            return False
        self.isVisted[start] = True
        for to in self.dic[start]:
            if to==end:
                flag = True
            else:
                flag = self.helper(to,end)
            if flag:
                return True
        return False
</code></pre>
<h4 id="547-朋友圈"><a href="#547-朋友圈" class="headerlink" title="547. 朋友圈"></a><a href="https://leetcode-cn.com/problems/friend-circles/" target="_blank" rel="noopener">547. 朋友圈</a></h4><p>思路1：dfs</p>
<p>对每个人都做一遍dfs搜索，然后再对他们的朋友做dfs搜索，需要注意的是需要用visited的数组进行提前剪枝，如果这个单位已经在数组里面说明这个人被访问过，不用再访问他的朋友们</p>
<pre><code>class Solution:
    def findCircleNum(self, M: List[List[int]]) -&gt; int:
        # dfs
        N = len(M)
        ans = 0
        visited = set()
        def dfs(i):
            for j in range(N):
                if M[i][j] and j not in visited:
                    visited.add(j)
                    dfs(j)
        for i in range(N):
            if i not in visited:
                ans+=1
                visited.add(i)
                dfs(i)
        return ans
</code></pre><p>思路二、并查集</p>
<pre><code class="lang-python">class Solution:
    def findCircleNum(self, M: List[List[int]]) -&gt; int:
        parent = {}
        size = {}
        self.ans = len(M)
        def find_root(x):
            if x not in parent.keys():
                parent[x] = x
            while x!=parent[x]:
                x = parent[x]
                parent[x] = parent[parent[x]]
            return x
        def union(x,y):
            root_x = find_root(x)
            root_y = find_root(y)
            if root_x==root_y:#说明这俩已经在一起了
                return 
            if root_x not in size.keys():
                size[root_x] = 1
            if root_y not in size.keys():
                size[root_y] = 1    
            if size[root_x]&lt;size[root_y]:
                parent[root_x] = root_y
                size[root_x]+=size[root_y]
            else:
                parent[root_y] = root_x
                size[root_y]+=size[root_x]
            self.ans-=1
        for i in range(len(M)):
            for j in range(i+1,len(M)):
                if M[i][j]==1:
                    union(i,j)
        return self.ans
</code></pre>
<h4 id="684-冗余连接"><a href="#684-冗余连接" class="headerlink" title="684. 冗余连接"></a><a href="https://leetcode-cn.com/problems/redundant-connection/" target="_blank" rel="noopener">684. 冗余连接</a></h4><p>基础的并查集，就像老哥题解中写的  找爹</p>
<pre><code class="lang-python">class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -&gt; List[int]:
        parents = list(range(len(edges) + 1))  #爹们排排站好,注意这里parents只用了1-最后一个，最前面索引为0的没有用
        # print(parents)
        def findP(x):
            if parents[x] != x:       
                parents[x] = findP(parents[x])  #一直找到最后的老爹
            return parents[x]

        for x, y in edges:      #遍历数组
            px, py = findP(x), findP(y)
            if px != py:        #如果两个人的爹不一样，就根据规则让他们相认！
                parents[py] = px
            else:
                return [x, y]   #爹是一个人，说明他们本来就有一个爹了，都和这个爹相连接，但是现在又要让他们加上一层连接，就多余了。于是答案就是这两个数。


# 作者：flying_du
# 链接：https://leetcode-cn.com/problems/redundant-connection/solution/python3-quan-guo-zui-cai-zhao-die-you-xi-by-flying/
# 来源：力扣（LeetCode）
# 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<p>还有一种写法存疑的点是什么时候p[2]改变了？</p>
<pre><code class="lang-python">def findRedundantConnection(edges):
    p = {i: {i} for i in range(1, len(edges) + 1)}  #并查集初始化，{1: {1}, 2: {2}, 3: {3}, 4: {4}}
    for x, y in edges:
        if p[x] is not p[y]:    #如果两个集合地址不一样
            p[x] |= p[y]        #合并集合
            for z in p[y]:
                p[z] = p[x]     #修改元素集合标记的指针地址
        else:
            return [x, y]
</code></pre>
<h4 id="149-直线上最多的点数"><a href="#149-直线上最多的点数" class="headerlink" title="149. 直线上最多的点数"></a><a href="https://leetcode-cn.com/problems/max-points-on-a-line/" target="_blank" rel="noopener">149. 直线上最多的点数</a></h4><p>注意点为</p>
<pre><code class="lang-python">class Solution:
    def maxPoints(self, points: List[List[int]]) -&gt; int:
        res = 0
        if not points:
            return res
        if len(points) == 1:
            return 1
        for i in range(len(points)-1):
            dic = {}
            same = 0
            curMax = 0
            for j in range(i+1, len(points)):
                if points[i] == points[j]:
                    same += 1
                    continue
                if (points[i][0] - points[j][0]) == 0:
                    rate = float(&#39;inf&#39;)
                else:
                    rate = (points[i][1] - points[j][1]) * 1000 / (points[i][0] - points[j][0]) * 1000
                dic[rate] = dic.get(rate, 0) + 1
                curMax = max(curMax, dic[rate])
            res = max(res, curMax+same+1)
        return res



# 作者：lionKing_njuer
# 链接：https://leetcode-cn.com/problems/max-points-on-a-line/solution/python3-zi-dian-xie-lu-149-by-lionking_njuer/
# 来源：力扣（LeetCode）
# 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<h4 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">222. 完全二叉树的节点个数</a></h4><p>比较左右节点的高度，利用完全二叉树的特点，如果左右高度相等，那么左子树肯定是全的，否则（左子树的高度大于右子树的高度），说明右子树肯定是全的。</p>
<pre><code class="lang-python">class Solution:
    def countNodes(self, root: TreeNode) -&gt; int:
        if not root:
            return 0
        lh,rh = self.getheight(root.left),self.getheight(root.right)
        if lh==rh:
            return (pow(2,lh))+self.countNodes(root.right)
        else:
            return (pow(2,rh))+self.countNodes(root.left)
    def getheight(self,root):
        ret = 0
        while root:
            ret+=1
            root = root.left
        return ret
</code></pre>
<h4 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11. 盛最多水的容器</a></h4><pre><code class="lang-python">class Solution:
    def maxArea(self, height: List[int]) -&gt; int:
        i, j = 0, len(height)-1
        max_area = 0
        while i&lt;j:
            if height[i]&lt;height[j]:
                area = (j-i)*height[i]
                i+=1
            else:
                area = (j-i)*height[j]
                j-=1
            max_area = max(area,max_area)
        return max_area
</code></pre>
<h4 id="875-爱吃香蕉的珂珂"><a href="#875-爱吃香蕉的珂珂" class="headerlink" title="875. 爱吃香蕉的珂珂"></a><a href="https://leetcode-cn.com/problems/koko-eating-bananas/" target="_blank" rel="noopener">875. 爱吃香蕉的珂珂</a></h4><p>注意点一是二分法的时候先看是否大于目标值：left = mid+1，else：right = mid</p>
<p>注意点二是二分法的边界是1到max(piles) 左边界不用设置的特别大，到max(piles)即可</p>
<p>注意点三是左边界的可选项是1或者是min(piles),可以通过judge(piles, minn) 对比，如果judge(piles, minn) &gt;H说明即使按照列表中最少的香蕉数吃也会大于要求时长，即[1,minn]的范围内没有必要尝试，可以缩短尝试空间</p>
<pre><code class="lang-python">class Solution:
    def minEatingSpeed(self, piles: List[int], H: int) -&gt; int:
        def judge(piles,k):
            tmp = 0
            for num in piles:
                if num%k&gt;0:
                    tmp = tmp + (num//k)+1
                else:
                    tmp += num//k
            return tmp
        left = 1
        right = max(piles)
        while left&lt;right:
            mid = (left+right)//2
            if judge(piles,mid)&gt;H:#说明吃慢了
                left = mid+1
            else:
                right = mid
        return left
</code></pre>
<h4 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26. 删除排序数组中的重复项"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">26. 删除排序数组中的重复项</a></h4><pre><code class="lang-python">class Solution:
    def removeDuplicates(self, nums: List[int]) -&gt; int:
        for num_index in range(len(nums)-1,0,-1):
            if nums[num_index] == nums[num_index-1]:
                nums.pop(num_index)
        return len(nums)
</code></pre>
<h4 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">167. 两数之和 II - 输入有序数组</a></h4><pre><code class="lang-python">class Solution:
    def twoSum(self, numbers: List[int], target: int) -&gt; List[int]:
        left = 0
        right = len(numbers)-1
        while left&lt;right:
            if numbers[left]+numbers[right]==target:
                return [left+1,right+1]
            elif numbers[left]+numbers[right]&lt;target:
                left+=1
            else:
                right-=1
</code></pre>
<h4 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42. 接雨水</a></h4><p>双指针：</p>
<pre><code>class Solution:
    def trap(self, height: List[int]) -&gt; int:
        if not height or len(height)==1:
            return 0
        now_height = 1
        left = 0
        right = len(height) - 1
        num_sum = 0
        while left&lt;=right:
            while(left&lt;=right and height[left] &lt; now_height):
                left+=1
            while(left&lt;=right and height[right]&lt;now_height):
                right-=1
            num_sum+=(right-left+1)
            now_height+=1
        if num_sum-sum(height)&lt;0:
            return 0 
        else:
            return num_sum-sum(height)
</code></pre><p>利用数组进行比较：</p>
<pre><code class="lang-python">class Solution:
    def trap(self, height: List[int]) -&gt; int:
        # 边界条件
        if not height: return 0
        n = len(height)
        maxleft = [0] * n
        maxright = [0] * n
        ans = 0
        # 初始化
        maxleft[0] = height[0]
        maxright[n-1] = height[n-1]
        # 设置备忘录，分别存储左边和右边最高的柱子高度
        for i in range(1,n):
            maxleft[i] = max(height[i],maxleft[i-1])
        for j in range(n-2,-1,-1):
            maxright[j] = max(height[j],maxright[j+1])
        # 一趟遍历，比较每个位置可以存储多少水
        for i in range(n):
            if min(maxleft[i],maxright[i]) &gt; height[i]:
                ans += min(maxleft[i],maxright[i]) - height[i]
        return ans

作者：z1m
链接：https://leetcode-cn.com/problems/trapping-rain-water/solution/dong-tai-gui-hua-shuang-zhi-zhen-tu-jie-by-ml-zimi/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<h4 id="1002-查找常用字符"><a href="#1002-查找常用字符" class="headerlink" title="1002. 查找常用字符"></a><a href="https://leetcode-cn.com/problems/find-common-characters/" target="_blank" rel="noopener">1002. 查找常用字符</a></h4><pre><code class="lang-python">class Solution:
    def commonChars(self, A: List[str]) -&gt; List[str]:
        res = []
        if not A:
            return res
        key = set(A[0])
        for k in key:
            minnum = min(a.count(k) for a in A)
            res += minnum*k
        return res
</code></pre>
<h4 id="面试题-17-11-单词距离"><a href="#面试题-17-11-单词距离" class="headerlink" title="面试题 17.11. 单词距离"></a><a href="https://leetcode-cn.com/problems/find-closest-lcci/" target="_blank" rel="noopener">面试题 17.11. 单词距离</a></h4><pre><code class="lang-python">class Solution:
    def findClosest(self, words: List[str], word1: str, word2: str) -&gt; int:
        a = []
        b = []
        for i in range(len(words)):
            if words[i]==word1:
                a.append(i)
            if words[i]==word2:
                b.append(i)
        ans = float(&#39;inf&#39;)
        for i in a:
            for j in b:
                ans = min(ans,abs(i-j))
        return ans
</code></pre>
<h4 id="581-最短无序连续子数组"><a href="#581-最短无序连续子数组" class="headerlink" title="581. 最短无序连续子数组"></a><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/" target="_blank" rel="noopener">581. 最短无序连续子数组</a></h4><pre><code class="lang-python">class Solution:
    def findUnsortedSubarray(self, nums: List[int]) -&gt; int:
        sorted_num = sorted(nums)
        left = 0
        right = len(nums)-1
        while left&lt;=right:
            if sorted_num[left]==nums[left]:
                left+=1
            elif sorted_num[right]==nums[right]:
                right-=1
            else:
                break
        return right-left+1
</code></pre>
<h4 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a><a href="https://leetcode-cn.com/problems/partition-labels/" target="_blank" rel="noopener">763. 划分字母区间</a></h4><pre><code class="lang-python">class Solution:
    def partitionLabels(self, S: str) -&gt; List[int]:
        tmp = [0]*26
        for i,ch in enumerate(S):
            tmp[ord(ch)-ord(&#39;a&#39;)] = i
        ans = []
        start = end = 0
        for i ,ch in enumerate(S):
            end = max(end,tmp[ord(ch)-ord(&#39;a&#39;)])
            if i==end:
                ans.append(end-start+1)
                start = end+1
        return ans
</code></pre>
<h4 id="78-子集-2"><a href="#78-子集-2" class="headerlink" title="78. 子集"></a><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78. 子集</a></h4><pre><code class="lang-python">class Solution:
    def subsets(self, nums: List[int]) -&gt; List[List[int]]:
        ans = [[]]
        for i in range(len(nums)-1,-1,-1):
            for subans in ans[:]:
                ans.append(subans+[nums[i]])
        return ans
</code></pre>
<h4 id="62-不同路径-1"><a href="#62-不同路径-1" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a></h4><pre><code class="lang-python">class Solution:
    def uniquePaths(self, m: int, n: int) -&gt; int:
        def helper(i):
            tmp_ans = 1
            for i in range(i,0,-1):
                tmp_ans*=i
            return tmp_ans
        total_step = m+n-2
        down = m-1
        right = n-1
        return int(helper(total_step)/helper(down)/helper(right))
</code></pre>
<h4 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20. 有效的括号</a></h4><pre><code class="lang-python">class Solution:
    def isValid(self, s: str) -&gt; bool:
        stack = []
        mapping = {&quot;)&quot;:&quot;(&quot;,&quot;}&quot;:&quot;{&quot;,&quot;]&quot;:&quot;[&quot;}
        for char in s:
            if char in mapping:
                top_element = stack.pop() if stack else &#39;#&#39;
                if mapping[char]!=top_element:
                    return False
            else:
                stack.append(char)
        return not stack
</code></pre>
<h4 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">32. 最长有效括号</a></h4><pre><code class="lang-python">class Solution:
    def longestValidParentheses(self, s: str) -&gt; int:
        # s = &quot;()&quot;
        length = len(s)
        if length == 0:
            return 0
        dp = [0]*length
        for i in range(0,length):
            # print(i)
            if s[i]==&#39;)&#39;:
                pre = i-dp[i-1]-1
                if pre&gt;=0 and s[pre]==&#39;(&#39;:
                    dp[i] = dp[i-1]+2
                    if pre&gt;0:
                        dp[i]+=dp[pre-1]
        return max(dp)
</code></pre>
<h4 id="206-反转链表-1"><a href="#206-反转链表-1" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. 反转链表</a></h4><pre><code class="lang-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseList(self, head: ListNode) -&gt; ListNode:
        &quot;&quot;&quot;
        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        pre = None
        ans = head
        stack = []
        if ans is None:
            return []
        while ans.next is not None:
            stack.append(ans)
            ans = ans.next
        while len(stack)&gt;0: 
            current = stack.pop()
            current.next.next = current
        head.next = None
        return ans
</code></pre>
<pre><code>

</code></pre><h4 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">92. 反转链表 II</a></h4><pre><code class="lang-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseBetween(self, head: ListNode, m: int, n: int) -&gt; ListNode:
        res = ListNode(None)
        ret = ListNode(None)
        cur = res
        cur.next = head
        num = 0
        count = 0
        node = None
        while cur.next:
            if num&gt;=m-1:
                break
            cur = cur.next
            num+=1
        l2 = cur.next
        cur.next = None
        ret.next = l2
        while ret.next:
            if count == n-m+1:
                break
            ret = ret.next
            count+=1
        l3 = ret.next
        ret.next = None
        while l2:
            tmp = l2.next
            l2.next = node
            node = l2
            l2 = tmp
        cur.next = ret 
        while ret.next:
            ret = ret.next
        ret.next = l3
        return res.next
</code></pre>
<h4 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">25. K 个一组翻转链表</a></h4><pre><code class="lang-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseKGroup(self, head: ListNode, k: int) -&gt; ListNode:
        dummy = ListNode(0)
        p = dummy
        while True:
            count = k
            stack = []
            tmp = head
            while count and tmp:
                stack.append(tmp)
                tmp = tmp.next
                count-=1
            if count:
                p.next = head
                break
            while stack:
                p.next = stack.pop()
                p = p.next
            p.next = tmp
            head = tmp
        return dummy.next
</code></pre>
<blockquote>
<p>有一个班级有 n 个人，给出 n 个元素，第 i 个元素代表 第 i 位同学的考试成绩，接下进行 m 次询问，每次询问给出一个数值 t ，表示第 t 个同学，然后需要我们输出第 t 个同学的成绩超过班级百分之几的人，百分数 p 可以这样算：p = (不超过第 t 个同学分数的人数 ) / n * 100%。输出的时候保留到小数点后 6 位，并且需要四舍五入。</p>
<p>输入描述：第一行输入两个数 n 和 m，两个数以空格隔开，表示 n 个同学和 m 次询问。第二行输入 n 个数值 ni，表示每个同学的分数，第三行输入 m 个数值mi，表示每次询问是询问第几个同学。（注意，这里 2&lt;=n，m&lt;=100000，0&lt;=ni&lt;=150，1&lt;=mi&lt;=n）</p>
<p>输出描述：输出 m 行，每一行输出一个百分数 p，代表超过班级百分之几的人。</p>
<p>示例1：</p>
<p>输入 ：</p>
<p>3 2</p>
<p>50 60 70</p>
<p>1 2</p>
<p>输出</p>
<p>33.333333%</p>
<p>66.666667%</p>
</blockquote>
<pre><code class="lang-python">def func(self):
        n, m, scores, idx = self.getData()
        prefix = [0 for i in range(151)]
        for score in scores:
            prefix[score] += 1
        sum = 0
        for i in range(151):
            sum += prefix[i]
            prefix[i] = sum
        for i in idx:
            rate = prefix[scores[i-1]]/n
            print(&quot;%.6f&quot; % rate + &quot;%&quot;)
</code></pre>
<h4 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">208. 实现 Trie (前缀树)</a></h4><pre><code class="lang-python">class Trie:

    def __init__(self):
        &quot;&quot;&quot;
        Initialize your data structure here.
        &quot;&quot;&quot;
        self.lookup = {}


    def insert(self, word: str) -&gt; None:
        &quot;&quot;&quot;
        Inserts a word into the trie.
        &quot;&quot;&quot;
        tree = self.lookup
        for a in word:
            if a not in tree:
                tree[a] = {}
            tree =tree[a]
        tree[&#39;#&#39;] = &#39;#&#39;


    def search(self, word: str) -&gt; bool:
        &quot;&quot;&quot;
        Returns if the word is in the trie.
        &quot;&quot;&quot;
        tree = self.lookup
        for a in word:
            if a not in tree:
                return False
            tree = tree[a]
        if &#39;#&#39; in tree:
            return True
        return False


    def startsWith(self, prefix: str) -&gt; bool:
        &quot;&quot;&quot;
        Returns if there is any word in the trie that starts with the given prefix.
        &quot;&quot;&quot;
        tree = self.lookup
        for a in prefix:
            if a not in tree:
                return False
            tree = tree[a]
        return True



# Your Trie object will be instantiated and called as such:
# obj = Trie()
# obj.insert(word)
# param_2 = obj.search(word)
# param_3 = obj.startsWith(prefix)
</code></pre>
<h4 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">144. 二叉树的前序遍历</a></h4><p>思路：迭代</p>
<pre><code class="lang-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def preorderTraversal(self, root: TreeNode) -&gt; List[int]:
        if not root:
            return []
        stack = [root]
        res = []
        while stack:
            cur = stack.pop()
            res.append(cur.val)
            if cur.right:
                stack.append(cur.right)
            if cur.left:
                stack.append(cur.left)
        return res
</code></pre>
<p>递归：</p>
<pre><code class="lang-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def preorderTraversal(self, root: TreeNode) -&gt; List[int]:
        def dfs(root):
            if not root:
                return
            res.append(root.val)
            dfs(root.left)
            dfs(root.right)
        res = []
        dfs(root)
        return res
</code></pre>
<h4 id="821-字符的最短距离"><a href="#821-字符的最短距离" class="headerlink" title="821. 字符的最短距离"></a><a href="https://leetcode-cn.com/problems/shortest-distance-to-a-character/" target="_blank" rel="noopener">821. 字符的最短距离</a></h4><p>思路：从前向后遍历，再从后向前遍历，取两者最小值</p>
<pre><code class="lang-python">class Solution:
    def shortestToChar(self, S: str, C: str) -&gt; List[int]:
        prev = float(&#39;-inf&#39;)
        ans = []
        for i, x in enumerate(S):
            if x==C:
                prev = i
            ans.append(i-prev)
        prev = float(&#39;inf&#39;)
        for i in range(len(S)-1,-1,-1):
            if S[i]==C:
                prev = i
            ans[i] = min(ans[i],prev-i)
        return ans
</code></pre>
<p>需包装部分：</p>
<ul>
<li>状态<ul>
<li>红方<ul>
<li>airports机场信息</li>
<li>teams编队信息</li>
<li>units平台信息</li>
<li>qb情报信息</li>
<li>rockets发射导弹信息</li>
</ul>
</li>
<li>蓝方<ul>
<li>airports机场信息</li>
<li>teams编队信息</li>
<li>units平台信息</li>
<li>qb情报信息</li>
<li>rockets发射导弹信息</li>
</ul>
</li>
</ul>
</li>
<li>指令集<ul>
<li>开始，暂停，恢复，关闭指令</li>
<li>12种作战飞机指令<ul>
<li>4-飞机编队-巡逻</li>
<li>4-轰炸机-突击（区域和具体目标）</li>
<li>2-歼击机-护航</li>
<li>1-歼击机-空中拦截</li>
<li>1-飞机编队-返航</li>
</ul>
</li>
<li>5种地面防空指令<ul>
<li>1-添加指定目标</li>
<li>1-移除指定目标</li>
<li>1-雷达开关机</li>
<li>1-设置防御方向</li>
<li>1-机动至指定位置重新部署</li>
</ul>
</li>
<li>5种水面舰艇指令<ul>
<li>1-为舰船添加指定目标</li>
<li>1-为舰船移除指定目标</li>
<li>1-雷达开关机</li>
<li>1-舰船初始部署</li>
<li>1-舰船区域巡逻防空</li>
</ul>
</li>
<li>5种预警机指令<ul>
<li>2-预警机巡逻</li>
<li>1-预警机探测模式</li>
<li>1-预警机雷达开关机</li>
<li>1-探测任务取消</li>
</ul>
</li>
<li>5种干扰机指令<ul>
<li>区域干扰</li>
<li>航线干扰</li>
<li>设置干扰模式</li>
<li>关闭干扰</li>
<li>结束干扰</li>
</ul>
</li>
<li>3种无人机侦察<ul>
<li>区域侦察</li>
<li>航线巡逻</li>
<li>侦察任务取消</li>
</ul>
</li>
<li>1种地面雷达<ul>
<li>地面雷达开关机</li>
</ul>
</li>
</ul>
</li>
<li></li>
</ul>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 1415500736@qq.com </span>
    </div>
</article>


<p>
    <a href="javascript:void(0)" class="dashang" onclick="dashangToggle()">赏</a>
</p>


<div class="article_copyright">
    <p><span class="copy-title">文章标题:</span>leetcode</p>
    
    <p><span class="copy-title">本文作者:</span><a href="javascript:void(0)" title="Rock">Rock</a></p>
    <p><span class="copy-title">发布时间:</span>2020-08-05, 10:14:45</p>
    <p><span class="copy-title">最后更新:</span>2020-11-03, 09:30:02</p>
    <span class="copy-title">原始链接:</span><a class="post-url" href="/2020/08/05/lucifer-91/" title="leetcode">http://rock-blog.top/2020/08/05/lucifer-91/</a>
    <p>
        <span class="copy-title">版权声明:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target="_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
    </p>
</div>



    <div id="comments"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script type="text/javascript">
    $.getScript('/js/gitalk.js', function () {
        var gitalk = new Gitalk({
            clientID: 'e78b4c19bc08850d88df',
            clientSecret: '308b55a6d580ee7a819af0f950b3188be697ae29',
            repo: 'guobaoyo.github.io',
            owner: 'guobaoyo',
            admin: ['guobaoyo'],
            id: decodeURI(location.pathname),
            distractionFreeMode: 'true',
            language: 'zh-CN',
            perPage: parseInt('10',10)
        })
        gitalk.render('comments')
    })
</script>




    




    </div>
    <div class="copyright">
        <p class="footer-entry">©2016-2019 Rock&#39;s  blog</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full"><span class="min "></span></button>
<button class="post-toc-menu"><span class="post-toc-menu-icons"></span></button>
<div class="post-toc"><span class="post-toc-title">目录</span>
    <div class="post-toc-content">

    </div>
</div>
<a class id="rocket" href="javascript:void(0)"></a>
    </div>
</div>
<div class="acParent"></div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close" href="javascript:void(0)" onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.0.1"></script>

<script src="/js/script.js?v=1.0.1"></script>
<script>
    var img_resize = 'default';
    /*作者、标签的自动补全*/
    $(function () {
        $('.search').AutoComplete({
            'data': ['#三省吾身','#AI','#数学','#编程','#深度学习','#CV','#python','#强化学习','#技术小节','#go','#技术小结','#leetcode','#组会报告','#考研','#NLP',],
            'itemHeight': 20,
            'width': 418
        }).AutoComplete('show');
    })
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $(".post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().split('\n').length - 1, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0px;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: #fafafa;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
        .nav .hide-list.fullscreen {
            left: 492px
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #c1bfc1;
    }
    
    

    /*列表样式*/
    
    .post .pjax article .article-entry>ol, .post .pjax article .article-entry>ul, .post .pjax article>ol, .post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    .post .pjax article .article-entry li>ol, .post .pjax article .article-entry li>ul,.post .pjax article li>ol, .post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    .post .pjax article .article-entry>ol>li, .post .pjax article .article-entry>ul>li,.post .pjax article>ol>li, .post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    .post .pjax article .article-entry li>ol>li, .post .pjax article .article-entry li>ul>li,.post .pjax article li>ol>li, .post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    
    .nav-right:before {
        content: ' ';
        display: block;
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 0.5;
        background: url("https://i.loli.net/2019/07/22/5d3521411f3f169375.png");
        background-repeat: no-repeat;
        background-position: 50% 0;
        -ms-background-size: cover;
        -o-background-size: cover;
        -moz-background-size: cover;
        -webkit-background-size: cover;
        background-size: cover;
    }
    

    
</style>







</html>
