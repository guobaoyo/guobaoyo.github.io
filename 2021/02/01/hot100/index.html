<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <title>leetcodehot | Rock-Blog</title>
  <meta name="keywords" content=" python , 编程 , 技术小结 ">
  <meta name="description" content="leetcodehot | Rock-Blog">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="2020-09-25智能对抗初赛后的停顿与反思，全文主要 https://mp.weixin.qq.com/s/FFb1HZOQn48V-L7IhFgRGQ 或者 https://zhuanlan.zhihu.com/p/39999667 DRL近三年的应用成果分类 棋牌类游戏（麻将、德克萨斯等游戏）、Atari游戏、星际争霸达到专业玩家水平甚至超人类水平-deepmind  控制机械臂-open">
<meta name="keywords" content="数学,深度学习,强化学习">
<meta property="og:type" content="article">
<meta property="og:title" content="DRL_report">
<meta property="og:url" content="http://rock-blog.top/20120/09/25/DRL-report/index.html">
<meta property="og:site_name" content="Rock-Blog">
<meta property="og:description" content="2020-09-25智能对抗初赛后的停顿与反思，全文主要 https://mp.weixin.qq.com/s/FFb1HZOQn48V-L7IhFgRGQ 或者 https://zhuanlan.zhihu.com/p/39999667 DRL近三年的应用成果分类 棋牌类游戏（麻将、德克萨斯等游戏）、Atari游戏、星际争霸达到专业玩家水平甚至超人类水平-deepmind  控制机械臂-open">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://rock-blog.top/20120/09/25/DRL-report/D:/rockblog/source/rockblog/source/_posts/DRL-report/1.jpg">
<meta property="og:updated_time" content="2020-09-26T13:30:39.729Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DRL_report">
<meta name="twitter:description" content="2020-09-25智能对抗初赛后的停顿与反思，全文主要 https://mp.weixin.qq.com/s/FFb1HZOQn48V-L7IhFgRGQ 或者 https://zhuanlan.zhihu.com/p/39999667 DRL近三年的应用成果分类 棋牌类游戏（麻将、德克萨斯等游戏）、Atari游戏、星际争霸达到专业玩家水平甚至超人类水平-deepmind  控制机械臂-open">
<meta name="twitter:image" content="http://rock-blog.top/20120/09/25/DRL-report/D:/rockblog/source/rockblog/source/_posts/DRL-report/1.jpg">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.0.1" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.0.1" rel="stylesheet">

<link href="//cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet">
<link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="/js/jquery.autocomplete.min.js?v=1.0.1"></script>

<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>



<script src="//cdn.bootcss.com/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>

<script src="/js/iconfont.js?v=1.0.1"></script>

</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="true">
  <input class="theme_blog_path" value>
</div>

<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="/img/avatar.jpg">
</a>
<div class="author">
    <span>Rock</span>
</div>

<div class="icon">
    
        
        <a title="github" href="https://github.com/guobaoyo" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-github"/>
                </svg>
            
        </a>
        
    
        
        <a title="email" href="mailto:1415500736@qq.com" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-email"/>
                </svg>
            
        </a>
        
    
        
        <a title="qq" href="http://wpa.qq.com/msgrd?v=3&uin=1415500736&site=qq&menu=yes" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-qq"/>
                </svg>
            
        </a>
        
    
        
        <a title="neteasemusic" href="https://music.163.com/#/user/home?id=280020740" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-neteasemusic"/>
                </svg>
            
        </a>
        
    
</div>




<ul>
    <li><div class="all active">全部文章<small>(50)</small></div></li>
    
        
            
            <li><div data-rel="三省吾身">三省吾身<small>(5)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="AI">AI<small>(8)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="强化学习">强化学习<small>(16)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="编程">编程<small>(17)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="数学">数学<small>(2)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="组会报告">组会报告<small>(1)</small></div>
                
            </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    
    
    </div>
    <div><a class="friends">友链</a></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="50">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="back-title-list"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
            <li><a target="_blank" href="http://zivblog.top">王金锋</a></li>
            
            <li><a target="_blank" href="http://yearing1017.cn/">进哥</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <form onkeydown="if(event.keyCode==13){return false;}">
        <input class="search" type="text" placeholder="以 in: 开头进行全文搜索" autocomplete="off" id="local-search-input">
        <i class="cross"></i>
        <span>
            <label for="tagswitch">Tags:</label>
            <input id="tagswitch" type="checkbox" style="display: none">
            <i id="tagsWitchIcon"></i>
        </span>
    </form>
    <div class="tags-list">
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">三省吾身</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">AI</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">数学</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">深度学习</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">CV</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">python</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">编程</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">强化学习</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">技术小节</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">技术小结</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">go</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">leetcode</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">组会报告</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">考研</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">NLP</a>
    </li>
    
    <div class="clearfix"></div>
</div>

    
    <div id="local-search-result">

    </div>
    
    <nav id="title-list-nav">
        
        <a class="三省吾身 " href="/2019/07/08/20190708日记/" data-tag="三省吾身,AI,数学" data-author>
            <span class="post-title" title="20190708日记">20190708日记</span>
            <span class="post-date" title="2019-07-08 19:43:26">2019/07/08</span>
        </a>
        
        <a class="三省吾身 " href="/2019/04/29/DLwords/" data-tag="AI,深度学习" data-author>
            <span class="post-title" title="DLwords">DLwords</span>
            <span class="post-date" title="2019-04-29 19:17:39">2019/04/29</span>
        </a>
        
        <a class="AI " href="/2019/05/08/DLwithPython/" data-tag="深度学习,CV,python" data-author>
            <span class="post-title" title="DeepLearning with Python">DeepLearning with Python</span>
            <span class="post-date" title="2019-05-08 17:54:01">2019/05/08</span>
        </a>
        
        <a class="强化学习 " href="/2020/06/08/A-algorithm/" data-tag="AI,数学,编程" data-author>
            <span class="post-title" title="A*_algorithm">A*_algorithm</span>
            <span class="post-date" title="2020-06-08 21:25:01">2020/06/08</span>
        </a>
        
        <a class="强化学习 " href="/2019/09/10/RL-DP-note/" data-tag="AI,深度学习,强化学习" data-author>
            <span class="post-title" title="RL_DP">RL_DP</span>
            <span class="post-date" title="2019-09-10 21:25:01">2019/09/10</span>
        </a>
        
        <a class="强化学习 " href="/2019/08/20/RL-MP-MRP-MDP-note/" data-tag="AI,深度学习,强化学习" data-author>
            <span class="post-title" title="RL_MDP">RL_MDP</span>
            <span class="post-date" title="2019-08-20 21:25:01">2019/08/20</span>
        </a>
        
        <a class="强化学习 " href="/2020/08/02/RL-PPO-note/" data-tag="AI,深度学习,强化学习" data-author>
            <span class="post-title" title="pg_note">pg_note</span>
            <span class="post-date" title="2020-08-02 21:25:01">2020/08/02</span>
        </a>
        
        <a class="AI " href="/20120/09/25/DRL-report/" data-tag="数学,深度学习,强化学习" data-author>
            <span class="post-title" title="DRL_report">DRL_report</span>
            <span class="post-date" title="20120-09-25 19:17:39">20120/09/25</span>
        </a>
        
        <a class="强化学习 " href="/2019/07/21/RL-basic-note/" data-tag="AI,深度学习,强化学习" data-author>
            <span class="post-title" title="rl_basic_note">rl_basic_note</span>
            <span class="post-date" title="2019-07-21 21:25:01">2019/07/21</span>
        </a>
        
        <a class="强化学习 " href="/2020/07/31/RL_A3C_A2C_note/" data-tag="AI,深度学习,强化学习" data-author>
            <span class="post-title" title="A3C_note">A3C_note</span>
            <span class="post-date" title="2020-07-31 21:25:01">2020/07/31</span>
        </a>
        
        <a class="强化学习 " href="/2019/07/26/RL_AC-note/" data-tag="AI,深度学习,强化学习" data-author>
            <span class="post-title" title="ac_note">ac_note</span>
            <span class="post-date" title="2019-07-26 21:25:01">2019/07/26</span>
        </a>
        
        <a class="强化学习 " href="/2019/07/21/RL_pg-note/" data-tag="AI,深度学习,强化学习" data-author>
            <span class="post-title" title="pg_note">pg_note</span>
            <span class="post-date" title="2019-07-21 21:25:01">2019/07/21</span>
        </a>
        
        <a class="编程 " href="/2020/10/08/docker-base/" data-tag="python,编程,技术小节" data-author>
            <span class="post-title" title="docker-base">docker-base</span>
            <span class="post-date" title="2020-10-08 17:54:01">2020/10/08</span>
        </a>
        
        <a class="强化学习 " href="/2020/01/26/RLTF/" data-tag="AI,数学,强化学习" data-author>
            <span class="post-title" title="RLTF">RLTF</span>
            <span class="post-date" title="2020-01-26 19:21:06">2020/01/26</span>
        </a>
        
        <a class="编程 " href="/2020/09/25/effective-python/" data-tag="python,技术小节" data-author>
            <span class="post-title" title="effective_python_note">effective_python_note</span>
            <span class="post-date" title="2020-09-25 19:17:39">2020/09/25</span>
        </a>
        
        <a class="强化学习 " href="/2020/07/12/atari-env-note/" data-tag="深度学习,编程,强化学习" data-author>
            <span class="post-title" title="Atari游戏环境笔记">Atari游戏环境笔记</span>
            <span class="post-date" title="2020-07-12 10:00:12">2020/07/12</span>
        </a>
        
        <a class="AI " href="/2021/03/03/interview-question/" data-tag="AI,python,技术小结" data-author>
            <span class="post-title" title="面试问题总结">面试问题总结</span>
            <span class="post-date" title="2021-03-03 20:19:39">2021/03/03</span>
        </a>
        
        <a class="编程 " href="/2019/07/23/go-http搭建服务器知识点儿/" data-tag="编程,go" data-author>
            <span class="post-title" title="go-http搭建服务器知识点儿">go-http搭建服务器知识点儿</span>
            <span class="post-date" title="2019-07-23 11:29:08">2019/07/23</span>
        </a>
        
        <a class="编程 " href="/2020/01/31/leetcode/" data-tag="数学,python,编程" data-author>
            <span class="post-title" title="leetcode">leetcode</span>
            <span class="post-date" title="2020-01-31 10:14:45">2020/01/31</span>
        </a>
        
        <a class href="/2020/06/05/lgb-note/" data-tag="AI,python,编程" data-author>
            <span class="post-title" title="lgb_note">lgb_note</span>
            <span class="post-date" title="2020-06-05 21:25:01">2020/06/05</span>
        </a>
        
        <a class="强化学习 " href="/2020/07/06/rl-questions/" data-tag="AI,深度学习,强化学习" data-author>
            <span class="post-title" title="RL_questions">RL_questions</span>
            <span class="post-date" title="2020-07-06 21:25:01">2020/07/06</span>
        </a>
        
        <a class="数学 " href="/2019/04/25/math/" data-tag="AI,数学,深度学习" data-author>
            <span class="post-title" title="线性代数补充笔记">线性代数补充笔记</span>
            <span class="post-date" title="2019-04-25 21:25:01">2019/04/25</span>
        </a>
        
        <a class="AI " href="/2020/06/02/pytorch-note/" data-tag="AI,python,技术小结" data-author>
            <span class="post-title" title="pytorch_note">pytorch_note</span>
            <span class="post-date" title="2020-06-02 20:19:39">2020/06/02</span>
        </a>
        
        <a class="编程 " href="/2020/07/06/sword-offer04/" data-tag="python,技术小结,leetcode" data-author>
            <span class="post-title" title="剑指offer04">剑指offer04</span>
            <span class="post-date" title="2020-07-06 20:19:39">2020/07/06</span>
        </a>
        
        <a class="AI " href="/2019/09/14/deep-reinforcement-learning/" data-tag="数学,深度学习,强化学习" data-author>
            <span class="post-title" title="deep-reinforcement-learning">deep-reinforcement-learning</span>
            <span class="post-date" title="2019-09-14 10:00:12">2019/09/14</span>
        </a>
        
        <a class="编程 " href="/2020/07/06/sword-offer05/" data-tag="python,技术小结,leetcode" data-author>
            <span class="post-title" title="剑指offer05">剑指offer05</span>
            <span class="post-date" title="2020-07-06 20:19:39">2020/07/06</span>
        </a>
        
        <a class="编程 " href="/2020/07/07/sword-offer06/" data-tag="python,技术小结,leetcode" data-author>
            <span class="post-title" title="剑指offer06">剑指offer06</span>
            <span class="post-date" title="2020-07-07 20:19:39">2020/07/07</span>
        </a>
        
        <a class="编程 " href="/2020/07/08/sword-offer07/" data-tag="python,技术小结,leetcode" data-author>
            <span class="post-title" title="剑指offer07">剑指offer07</span>
            <span class="post-date" title="2020-07-08 20:19:39">2020/07/08</span>
        </a>
        
        <a class="编程 " href="/2020/07/09/sword-offer09/" data-tag="python,技术小结,leetcode" data-author>
            <span class="post-title" title="剑指offer09">剑指offer09</span>
            <span class="post-date" title="2020-07-09 20:19:39">2020/07/09</span>
        </a>
        
        <a class="强化学习 " href="/2020/06/11/tianshou-a2c-note/" data-tag="AI,编程,强化学习" data-author>
            <span class="post-title" title="tianshou平台源码阅读笔记">tianshou平台源码阅读笔记</span>
            <span class="post-date" title="2020-06-11 21:25:01">2020/06/11</span>
        </a>
        
        <a class="编程 " href="/2020/07/10/sword-offer11/" data-tag="python,技术小结,leetcode" data-author>
            <span class="post-title" title="剑指offer10">剑指offer10</span>
            <span class="post-date" title="2020-07-10 20:19:39">2020/07/10</span>
        </a>
        
        <a class="编程 " href="/2020/07/04/sword-offer03/" data-tag="python,技术小结,leetcode" data-author>
            <span class="post-title" title="剑指offer03">剑指offer03</span>
            <span class="post-date" title="2020-07-04 20:19:39">2020/07/04</span>
        </a>
        
        <a class="编程 " href="/2020/07/10/sword-offer10/" data-tag="python,技术小结,leetcode" data-author>
            <span class="post-title" title="剑指offer10">剑指offer10</span>
            <span class="post-date" title="2020-07-10 20:19:39">2020/07/10</span>
        </a>
        
        <a class="编程 " href="/2019/04/29/使用Python实现excel中固定数据排序且改名至另一个文件夹/" data-tag="python,编程,技术小结" data-author>
            <span class="post-title" title="基于python实现excel中读取文件目录+相应数据排序+将文件重命名">基于python实现excel中读取文件目录+相应数据排序+将文件重命名</span>
            <span class="post-date" title="2019-04-29 19:30:06">2019/04/29</span>
        </a>
        
        <a class="AI " href="/2020/06/02/强化学习在滴滴网约车的应用记录/" data-tag="AI,强化学习,组会报告" data-author>
            <span class="post-title" title="强化学习在滴滴网约车的应用笔记">强化学习在滴滴网约车的应用笔记</span>
            <span class="post-date" title="2020-06-02 20:19:39">2020/06/02</span>
        </a>
        
        <a class="三省吾身 " href="/2021/02/05/不正经/" data-tag="三省吾身" data-author>
            <span class="post-title" title="老不正经">老不正经</span>
            <span class="post-date" title="2021-02-05 21:12:21">2021/02/05</span>
        </a>
        
        <a class="数学 " href="/2019/10/24/数值计算与凸优化补充笔记/" data-tag="AI,数学,深度学习" data-author>
            <span class="post-title" title="数值计算与凸优化补充笔记">数值计算与凸优化补充笔记</span>
            <span class="post-date" title="2019-10-24 16:14:54">2019/10/24</span>
        </a>
        
        <a class="强化学习 " href="/2020/10/23/tstar/" data-tag="AI,深度学习,强化学习" data-author>
            <span class="post-title" title="Tstarbots_note">Tstarbots_note</span>
            <span class="post-date" title="2020-10-23 21:25:01">2020/10/23</span>
        </a>
        
        <a class="三省吾身 " href="/2019/11/03/智源大会听报告笔记/" data-tag="三省吾身,AI" data-author>
            <span class="post-title" title="智源大会听学术报告笔记">智源大会听学术报告笔记</span>
            <span class="post-date" title="2019-11-03 13:24:12">2019/11/03</span>
        </a>
        
        <a class="组会报告 " href="/2019/09/26/组会报告-0930-QLearning/" data-tag="深度学习,强化学习,组会报告" data-author>
            <span class="post-title" title="组会报告-0930-QLearning">组会报告-0930-QLearning</span>
            <span class="post-date" title="2019-09-26 15:15:04">2019/09/26</span>
        </a>
        
        <a class="编程 " href="/2019/09/05/物体检测打标小脚本-获取当前图片中鼠标位置/" data-tag="python,编程,技术小结" data-author>
            <span class="post-title" title="物体检测打标小脚本-获取当前图片中鼠标位置">物体检测打标小脚本-获取当前图片中鼠标位置</span>
            <span class="post-date" title="2019-09-05 15:30:36">2019/09/05</span>
        </a>
        
        <a class="三省吾身 " href="/2019/04/15/考研历程反思总结/" data-tag="三省吾身,考研" data-author>
            <span class="post-title" title="考研历程反思总结">考研历程反思总结</span>
            <span class="post-date" title="2019-04-15 21:25:01">2019/04/15</span>
        </a>
        
        <a class="AI " href="/2019/07/21/计算机视觉存疑解答记录/" data-tag="AI,数学,CV" data-author>
            <span class="post-title" title="计算机视觉存疑解答记录">计算机视觉存疑解答记录</span>
            <span class="post-date" title="2019-07-21 13:04:25">2019/07/21</span>
        </a>
        
        <a class="编程 " href="/2020/07/19/动态规划/" data-tag="python,技术小结,leetcode" data-author>
            <span class="post-title" title="剑指offer10">剑指offer10</span>
            <span class="post-date" title="2020-07-19 20:19:39">2020/07/19</span>
        </a>
        
        <a class="AI " href="/2019/07/29/达观杯比赛记录/" data-tag="三省吾身,AI,NLP" data-author>
            <span class="post-title" title="达观杯比赛记录">达观杯比赛记录</span>
            <span class="post-date" title="2019-07-29 20:19:39">2019/07/29</span>
        </a>
        
        <a class="强化学习 " href="/2020/07/31/智能博弈挑战赛-note/" data-tag="AI,深度学习,强化学习" data-author>
            <span class="post-title" title="智能博弈挑战赛">智能博弈挑战赛</span>
            <span class="post-date" title="2020-07-31 21:25:01">2020/07/31</span>
        </a>
        
        <a class="强化学习 " href="/2019/08/05/RL-DDPG-note/" data-tag="AI,深度学习,强化学习" data-author>
            <span class="post-title" title="Aatri_A2c&amp;ppo">Aatri_A2c&amp;ppo</span>
            <span class="post-date" title="2019-08-05 21:25:01">2019/08/05</span>
        </a>
        
        <a class="强化学习 " href="/2019/07/06/Atari-a2c/" data-tag="AI,深度学习,强化学习" data-author>
            <span class="post-title" title="Aatri_A3C_A2c">Aatri_A3C_A2c</span>
            <span class="post-date" title="2019-07-06 21:25:01">2019/07/06</span>
        </a>
        
        <a class="编程 " href="/2021/02/01/hot100/" data-tag="python,编程,技术小结" data-author>
            <span class="post-title" title="leetcodehot">leetcodehot</span>
            <span class="post-date" title="2021-02-01 20:19:39">2021/02/01</span>
        </a>
        
        <a class="编程 " href="/2020/08/05/lucifer-91/" data-tag="数学,python,编程" data-author>
            <span class="post-title" title="leetcode">leetcode</span>
            <span class="post-date" title="2020-08-05 10:14:45">2020/08/05</span>
        </a>
        
    </nav>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div class="post">
    <div class="pjax">
        <article id="post-hot100" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">leetcodehot</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            
                <a href="javascript:" data-rel="编程">编程</a>
            
        </span>
        
        
        <span class="tag">
            
            <a href="javascript:" class="color2">python</a>
            
            <a href="javascript:" class="color3">编程</a>
            
            <a href="javascript:" class="color5">技术小结</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
        创建时间:<time class="date" title="更新时间: 2021-03-03 18:13:04">2021-02-01 20:19</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            阅读:<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
        <span class="top-comment" title="跳转至评论区">
            <a href="#comments">
                评论:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-两数之和hot100"><span class="toc-text">1. 两数之和hot100 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#167-两数之和-II-输入有序数组"><span class="toc-text">167. 两数之和 II - 输入有序数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#653-两数之和-IV-输入-BST"><span class="toc-text">653. 两数之和 IV - 输入 BST</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#560-和为K的子数组"><span class="toc-text">560. 和为K的子数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-三数之和hot100"><span class="toc-text">15. 三数之和hot100 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-四数之和"><span class="toc-text">18. 四数之和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-两数相加hot100"><span class="toc-text">2. 两数相加hot100 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#445-两数相加-II"><span class="toc-text">445. 两数相加 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#67-二进制求和"><span class="toc-text">67. 二进制求和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#371-两整数之和"><span class="toc-text">371. 两整数之和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#415-字符串相加"><span class="toc-text">415. 字符串相加</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#989-数组形式的整数加法"><span class="toc-text">989. 数组形式的整数加法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#43-字符串相乘"><span class="toc-text">43. 字符串相乘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-无重复字符的最长子串hot100"><span class="toc-text">3. 无重复字符的最长子串hot100 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#76-最小覆盖子串"><span class="toc-text">76. 最小覆盖子串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-有效的括号hot100"><span class="toc-text">20. 有效的括号hot100 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-最长回文子串hot100"><span class="toc-text">5. 最长回文子串hot100 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#516-最长回文子序列"><span class="toc-text">516. 最长回文子序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#647-回文子串"><span class="toc-text">647. 回文子串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-寻找两个正序数组的中位数"><span class="toc-text">4. 寻找两个正序数组的中位数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-盛最多水的容器hot100"><span class="toc-text">11. 盛最多水的容器hot100 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#238-除自身以外数组的乘积"><span class="toc-text">238. 除自身以外数组的乘积</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#42-接雨水"><span class="toc-text">42. 接雨水</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-最接近的三数之和"><span class="toc-text">16. 最接近的三数之和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#401-二进制手表"><span class="toc-text">401. 二进制手表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-括号生成hot100"><span class="toc-text">22. 括号生成hot100 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-电话号码的字母组合hot100"><span class="toc-text">17. 电话号码的字母组合hot100 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#46-全排列hot100"><span class="toc-text">46. 全排列hot100 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#47-全排列-II"><span class="toc-text">47. 全排列 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-删除链表的倒数第-N-个结点hot100"><span class="toc-text">19. 删除链表的倒数第 N 个结点hot100 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#39-组合总和hot100"><span class="toc-text">39. 组合总和hot100 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#40-组合总和-II"><span class="toc-text">40. 组合总和 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#216-组合总和-III"><span class="toc-text">216. 组合总和 III</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#77-组合"><span class="toc-text">77. 组合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1003-检查替换后的词是否有效"><span class="toc-text">1003. 检查替换后的词是否有效</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-合并两个有序链表hot100"><span class="toc-text">21. 合并两个有序链表hot100 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#263-丑数"><span class="toc-text">263. 丑数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#264-丑数-II"><span class="toc-text">264. 丑数 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23-合并K个升序链表"><span class="toc-text">23. 合并K个升序链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#31-下一个排列hot100"><span class="toc-text">31. 下一个排列hot100 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#60-排列序列"><span class="toc-text">60. 排列序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32-最长有效括号"><span class="toc-text">32. 最长有效括号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33-搜索旋转排序数组hot100"><span class="toc-text">33. 搜索旋转排序数组hot100 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#81-搜索旋转排序数组-II"><span class="toc-text">81. 搜索旋转排序数组 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#153-寻找旋转排序数组中的最小值"><span class="toc-text">153. 寻找旋转排序数组中的最小值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#34-在排序数组中查找元素的第一个和最后一个位置hot100"><span class="toc-text">34. 在排序数组中查找元素的第一个和最后一个位置hot100 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#278-第一个错误的版本"><span class="toc-text">278. 第一个错误的版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#48-旋转图像hot100"><span class="toc-text">48. 旋转图像hot100 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#242-有效的字母异位词"><span class="toc-text">242. 有效的字母异位词</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#49-字母异位词分组hot100"><span class="toc-text">49. 字母异位词分组hot100 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#53-最大子序和hot100"><span class="toc-text">53. 最大子序和hot100 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#697-数组的度"><span class="toc-text">697. 数组的度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#152-乘积最大子数组"><span class="toc-text">152. 乘积最大子数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#376-摆动序列376-摆动序列"><span class="toc-text">376. 摆动序列376. 摆动序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#978-最长湍流子数组"><span class="toc-text">978. 最长湍流子数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#121-买卖股票的最佳时机"><span class="toc-text">121. 买卖股票的最佳时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#55-跳跃游戏hot100"><span class="toc-text">55. 跳跃游戏hot100 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#45-跳跃游戏-II"><span class="toc-text">45. 跳跃游戏 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#56-合并区间hot100"><span class="toc-text">56. 合并区间hot100 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#57-插入区间"><span class="toc-text">57. 插入区间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#495-提莫攻击"><span class="toc-text">495. 提莫攻击</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#763-划分字母区间"><span class="toc-text">763. 划分字母区间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#986-区间列表的交集"><span class="toc-text">986. 区间列表的交集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#62-不同路径hot100"><span class="toc-text">62. 不同路径hot100 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#63-不同路径-II"><span class="toc-text">63. 不同路径 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#64-最小路径和hot100"><span class="toc-text">64. 最小路径和hot100 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#174-地下城游戏"><span class="toc-text">174. 地下城游戏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#509-斐波那契数"><span class="toc-text">509. 斐波那契数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#70-爬楼梯hot100"><span class="toc-text">70. 爬楼梯hot100 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#746-使用最小花费爬楼梯"><span class="toc-text">746. 使用最小花费爬楼梯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1137-第-N-个泰波那契数"><span class="toc-text">1137. 第 N 个泰波那契数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#72-编辑距离hot100"><span class="toc-text">72. 编辑距离hot100 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#75-颜色分类hot100"><span class="toc-text">75. 颜色分类hot100 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#283-移动零"><span class="toc-text">283. 移动零</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#27-移除元素"><span class="toc-text">27. 移除元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#324-摆动排序-II"><span class="toc-text">324. 摆动排序 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#567-字符串的排列"><span class="toc-text">567. 字符串的排列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#78-子集hot100"><span class="toc-text">78. 子集hot100 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#209-长度最小的子数组"><span class="toc-text">209. 长度最小的子数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#79-单词搜索hot100"><span class="toc-text">79. 单词搜索hot100 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#94-二叉树的中序遍历hot100"><span class="toc-text">94. 二叉树的中序遍历hot100 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#144-二叉树的前序遍历"><span class="toc-text">144. 二叉树的前序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#145-二叉树的后序遍历"><span class="toc-text">145. 二叉树的后序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#101-对称二叉树hot100"><span class="toc-text">101. 对称二叉树hot100 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#96-不同的二叉搜索树hot100"><span class="toc-text">96. 不同的二叉搜索树hot100 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#98-验证二叉搜索树hot100"><span class="toc-text">98. 验证二叉搜索树hot100 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#102-二叉树的层序遍历hot100"><span class="toc-text">102. 二叉树的层序遍历hot100 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#104-二叉树的最大深度hot100"><span class="toc-text">104. 二叉树的最大深度hot100 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#105-从前序与中序遍历序列构造二叉树hot100"><span class="toc-text">105. 从前序与中序遍历序列构造二叉树hot100 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#114-二叉树展开为链表hot100"><span class="toc-text">114. 二叉树展开为链表hot100 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#888-公平的糖果棒交换"><span class="toc-text">888. 公平的糖果棒交换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#424-替换后的最长重复字符"><span class="toc-text">424. 替换后的最长重复字符</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>均非原创，题解来自评论区</p>
<a id="more"></a>
<h4 id="1-两数之和hot100"><a href="#1-两数之和hot100" class="headerlink" title="1. 两数之和hot100 "></a><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和</a><font color="red"><strong>hot100</strong> </font></h4><p>两种做法：</p>
<p>1.使用字典，将遍历到的值都放到字典（哈希表）中，以数值为键，以索引为值再找与之相对应的数值，用带有索引的哈希表肯定比第二种方法快很多</p>
<pre><code class="lang-python">class Solution:
    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:
        hashmap = {}
        for index,num in enumerate(nums):
            another_num = target - num
            if another_num in hashmap:
                return [hashmap[another_num],index]
            hashmap[num] = index
        return None
</code></pre>
<pre><code class="lang-python">class Solution:
    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:
        for num in nums:
            index = nums.index(num)
            nums[index] = None
            if target - num in nums:
                return [index, nums.index(target-num)]
        return None
</code></pre>
<p>注意点</p>
<ul>
<li>使用enumerate 比较方便</li>
<li>应该先计算index后设置为None，否则设置为None后会出现“num not in list”的错误</li>
</ul>
<h4 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">167. 两数之和 II - 输入有序数组</a></h4><pre><code class="lang-python">class Solution:
    def twoSum(self, numbers: List[int], target: int) -&gt; List[int]:
        left = 0
        right = len(numbers) - 1
        while left &lt; right:
            if numbers[left] + numbers[right] == target:
                return [left + 1, right + 1]
            elif numbers[left] + numbers[right] &lt; target:
                left += 1
            else:
                right -= 1
</code></pre>
<p>注意点</p>
<ul>
<li>使用while一直循环，部分情况需要注意是&lt;还是&lt;=</li>
<li>注意题目要求返回的是[0, 1]的索引号还是 [1, 2]的第n个</li>
</ul>
<h4 id="653-两数之和-IV-输入-BST"><a href="#653-两数之和-IV-输入-BST" class="headerlink" title="653. 两数之和 IV - 输入 BST"></a><a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/" target="_blank" rel="noopener">653. 两数之和 IV - 输入 BST</a></h4><pre><code class="lang-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def findTarget(self, root: TreeNode, k: int) -&gt; bool:
        def inorder(node):
            if not node:
                return []
            else:
                return inorder(node.left) + [node.val] + inorder(node.right)
        list_tree = inorder(root)
        left = 0
        right = len(list_tree) - 1
        while left &lt; right:
            if list_tree[left] + list_tree[right] &lt; k:
                left += 1
            elif list_tree[left] + list_tree[right] &gt; k:
                right -= 1
            else:
                return True
        return False
</code></pre>
<p>注意点</p>
<ul>
<li>使用中序遍历将二叉树转化为顺序列表</li>
<li>同167一样，用while进行循环</li>
</ul>
<h4 id="560-和为K的子数组"><a href="#560-和为K的子数组" class="headerlink" title="560. 和为K的子数组"></a><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">560. 和为K的子数组</a></h4><pre><code class="lang-python">class Solution:
    def subarraySum(self, nums: List[int], k: int) -&gt; int:
        # length = len(nums)
        # cnt = 0
        # for i in range(0,length):
        #     for j in range(i,length):
        #         if sum(nums[i:j+1])==k:
        #             cnt+=1
        # return cnt
        #上为暴力算法超时
        #下为前缀和(超时)
        # cnt = 0
        # length = len(nums)
        # prefix = [0]*(length+1)
        # for i in range(1,length+1):
        #     prefix[i] = prefix[i-1]+nums[i-1]
        # for i in range(1,length+1):
        #     for j in range(i,length+1):
        #         if prefix[j]-prefix[i-1]==k:
        #             cnt+=1
        # return cnt
        hash_num_times = {}
        hash_num_times[0] = 1
        num_now = 0
        ans = 0
        for i in range(len(nums)):
            num_now += nums[i]
            if num_now - k in hash_num_times:
                ans += hash_num_times[num_now - k]
            if num_now in hash_num_times:
                hash_num_times[num_now] += 1
            elif num_now not in hash_num_times:
                hash_num_times[num_now] = 1
        return ans
</code></pre>
<p>注意点</p>
<ul>
<li>hash_num_times 存放的是从第一个数到第n个数的和</li>
<li>每次都会减掉目标数值，如果剪掉后的数值和仍然在hash_num_times中，说明中间有一部分是正好符合目标值的，则有几个num_now - k 就加几个</li>
</ul>
<h4 id="15-三数之和hot100"><a href="#15-三数之和hot100" class="headerlink" title="15. 三数之和hot100 "></a><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15. 三数之和<font color="red"><strong>hot100</strong> </font></a></h4><pre><code class="lang-python">class Solution:
    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:
        ans = []
        nums = sorted(nums)
        print(nums)
        for i in range(len(nums)-2):
            if nums[i]&gt;0:
                break
            if i &gt; 0 and nums[i] == nums[i - 1]: continue
            j = i+1
            k = len(nums)-1
            while j&lt;k:
                tmp = nums[i]+nums[j]+nums[k]
                if tmp &lt; 0:
                    j+=1
                    while j&lt;k and nums[j]==nums[j-1]:
                        j+=1
                elif tmp&gt;0:
                    k-=1
                    while j&lt;k and nums[k]==nums[k+1]:
                        k-=1
                else:
                    ans.append([nums[i],nums[j],nums[k]])
                    j+=1
                    k-=1
                    while j&lt;k and nums[j]==nums[j-1]:
                        j+=1
                    while j&lt;k and nums[k]==nums[k+1]:
                        k-=1
        return ans
</code></pre>
<p>注意点</p>
<ul>
<li>对数组进行排序</li>
<li>i一开始等于len(nums) - 2,一直让i-=1 直到nums[i] &lt; 0</li>
<li>固定i，然后移动j与k转化为两数之和</li>
</ul>
<h4 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">18. 四数之和</a></h4><pre><code class="lang-python">class Solution:
    def fourSum(self, nums: List[int], target: int) -&gt; List[List[int]]:
        if not nums or len(nums) &lt; 4:
            return []
        nums.sort()
        res = []
        for a in range(len(nums)-3):
            if a &gt; 0 and nums[a] == nums[a-1]:
                continue
            for b in range(a+1,len(nums)-2):
                if b &gt; a+1 and nums[b] == nums[b-1]:
                    continue
                c = b+1
                d = len(nums)-1
                while c &lt; d:
                    sum = nums[a]+nums[b]+nums[c]+nums[d]
                    if sum == target:
                        res.append([nums[a],nums[b],nums[c],nums[d]])
                        while c&lt;d and nums[c] == nums[c+1]:
                            c += 1
                        while c&lt;d and nums[d] == nums[d-1]:
                            d -= 1
                        c += 1
                        d -= 1
                    elif sum &lt; target:
                        c += 1
                    else:
                        d -= 1
        return res
</code></pre>
<ul>
<li>同15三数之和</li>
</ul>
<hr>
<h4 id="2-两数相加hot100"><a href="#2-两数相加hot100" class="headerlink" title="2. 两数相加hot100 "></a><a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">2. 两数相加</a><font color="red"><strong>hot100</strong> </font></h4><pre><code class="lang-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:
        re = ListNode(0)
        r = re
        carry = 0  # 表示进位
        while(l1 or l2):
            if l1:
                x = l1.val
            else:
                x = 0
            if l2:
                y = l2.val
            else:
                y = 0
            sum_xy = carry + x + y
            carry = sum_xy // 10
            r.next = ListNode(sum_xy%10)
            r = r.next
            if(l1!=None):
                l1 = l1.next
            if(l2!=None):
                l2 = l2.next
        if carry &gt; 0:
            r.next = ListNode(1)
        return re.next
</code></pre>
<p>注意点</p>
<ul>
<li>用carry记录进位</li>
<li>r和re一开始相同，最后返回re就可以</li>
<li>注意前面的两个if 判断和后面的两个if判断，前面的是保证x和y的值，后面的if是一直往后挪</li>
</ul>
<h4 id="445-两数相加-II"><a href="#445-两数相加-II" class="headerlink" title="445. 两数相加 II"></a><a href="https://leetcode-cn.com/problems/add-two-numbers-ii/" target="_blank" rel="noopener">445. 两数相加 II</a></h4><pre><code class="lang-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:
        l1_stack = []
        l2_stack = []
        while l1:
            l1_stack.append(l1.val)
            l1 = l1.next
        while l2:
            l2_stack.append(l2.val)
            l2 = l2.next
        ans = None
        carry = 0
        while l1_stack or l2_stack or carry != 0:
            a = 0 if not l1_stack else l1_stack.pop()
            b = 0 if not l2_stack else l2_stack.pop()
            cur = a + b + carry
            carry = cur // 10
            now = cur % 10
            cur_node = ListNode(now)
            cur_node.next = ans
            ans = cur_node
        return ans
</code></pre>
<p>注意点</p>
<ul>
<li>关键点是题目中要求不能改变原来的链表，所以需要将两个链表的值都存入列表中，然后相加再组合</li>
<li>注意本道题是从后向前加起来的，所以用栈存储，再pop出来比较合适</li>
<li>需要扩展额外的空间，即空间复杂度增加</li>
</ul>
<h4 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67. 二进制求和"></a><a href="https://leetcode-cn.com/problems/add-binary/" target="_blank" rel="noopener">67. 二进制求和</a></h4><pre><code class="lang-python">class Solution:
    def addBinary(self, a: str, b: str) -&gt; str:
        r,p = &#39;&#39;,0
        d = len(b)-len(a)
        a = &#39;0&#39; * d + a
        b = &#39;0&#39; * -d + b
        for i,j in zip(a[::-1],b[::-1]):
            s = int(i)+int(j)+p
            r = str(s%2)+r#注意这里不能r+= str()  因为是字符串的形式而不是整数
            p = s//2
        return &#39;1&#39;+r if p else r
</code></pre>
<p>注意点</p>
<ul>
<li>注意不同长短的要补齐</li>
<li>在计算的时候需要逆序</li>
<li>且注意是r = str(s%2)+r 而非 r+=str(s%2)</li>
</ul>
<h4 id="371-两整数之和"><a href="#371-两整数之和" class="headerlink" title="371. 两整数之和"></a><a href="https://leetcode-cn.com/problems/sum-of-two-integers/" target="_blank" rel="noopener">371. 两整数之和</a></h4><pre><code class="lang-python">class Solution:
    def getSum(self, a: int, b: int) -&gt; int:
        MASK = 0x100000000
        MAX_INT = 0x7FFFFFFF
        MIN_INT = MAX_INT+1
        while b!=0:
            carry = (a&amp;b)&lt;&lt;1
            a = (a ^ b) % MASK
            b = carry % MASK
        return a if a&lt;=MAX_INT else ~((a % MIN_INT) ^ MAX_INT)
</code></pre>
<ul>
<li>无进位加法用异或运算</li>
<li>进位结果用与运算与移位运算得到</li>
</ul>
<h4 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a><a href="https://leetcode-cn.com/problems/add-strings/" target="_blank" rel="noopener">415. 字符串相加</a></h4><pre><code class="lang-python">class Solution:
    def addStrings(self, num1: str, num2: str) -&gt; str:
        map1 = {&#39;1&#39;:1,&#39;2&#39;:2,&#39;3&#39;:3,&#39;4&#39;:4,&#39;5&#39;:5,&#39;6&#39;:6,&#39;7&#39;:7,&#39;8&#39;:8,&#39;9&#39;:9,&#39;0&#39;:0}
        num1_int = 0
        length1 = len(num1)
        length2 = len(num2)
        for i,c in enumerate(num1):
            num1_int+=map1[c]*(10**(length1-1-i))
        num2_int = 0
        for i,c in enumerate(num2):
            num1_int+=map1[c]*(10**(length2-1-i))
        return str(num1_int+num2_int)
</code></pre>
<p>注意点</p>
<ul>
<li>将字符串中的每个字符按照字典转为数字</li>
</ul>
<h4 id="989-数组形式的整数加法"><a href="#989-数组形式的整数加法" class="headerlink" title="989. 数组形式的整数加法"></a><a href="https://leetcode-cn.com/problems/add-to-array-form-of-integer/" target="_blank" rel="noopener">989. 数组形式的整数加法</a></h4><pre><code class="lang-python">class Solution:
    def addToArrayForm(self, A: List[int], K: int) -&gt; List[int]:
        list_k = []
        str_k = str(K)
        while str_k:
            list_k.append(int(str_k[0]))
            str_k = str_k[1:]
        A = A[::-1]
        list_k = list_k[::-1]
        carry = 0
        ans = []
        while list_k or A or carry:
            if list_k:
                a = list_k[0]
            else:
                a = 0
            if A:
                b = A[0]
            else:
                b = 0
            list_k = list_k[1:]
            A = A[1:]
            num_now = a + b + carry
            num_to_append = num_now % 10
            carry = num_now // 10
            ans.append(num_to_append)
        print(ans)
        return ans[::-1]
</code></pre>
<pre><code class="lang-python">class Solution:
    def addToArrayForm(self, A: List[int], K: int) -&gt; List[int]:
        s = &quot;&quot;
        for it in A:
            s += str(it)
        s = str(int(s) + K);
        return list(s)
</code></pre>
<p>注意点</p>
<ul>
<li>第一种为笨蛋做法</li>
<li>第二种为评论区的简单做法</li>
</ul>
<h4 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43. 字符串相乘"></a><a href="https://leetcode-cn.com/problems/multiply-strings/" target="_blank" rel="noopener">43. 字符串相乘</a></h4><pre><code class="lang-python">class Solution:
    def multiply(self, num1: str, num2: str) -&gt; str:
        map1 = {&#39;1&#39;:1,&#39;2&#39;:2,&#39;3&#39;:3,&#39;4&#39;:4,&#39;5&#39;:5,&#39;6&#39;:6,&#39;7&#39;:7,&#39;8&#39;:8,&#39;9&#39;:9,&#39;0&#39;:0}
        num1_int = 0
        length1 = len(num1)
        length2 = len(num2)
        for i,c in enumerate(num1):
            num1_int+=map1[c]*(10**(length1-1-i))
        num2_int = 0
        for i,c in enumerate(num2):
            num2_int+=map1[c]*(10**(length2-1-i))
        print(num1_int)
        print(num2_int)
        return str(num1_int*num2_int)
</code></pre>
<p>注意点</p>
<ul>
<li>同415，先将字符串转为整数，做运算后再转为字符串</li>
</ul>
<h4 id="3-无重复字符的最长子串hot100"><a href="#3-无重复字符的最长子串hot100" class="headerlink" title="3. 无重复字符的最长子串hot100 "></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a><font color="red"><strong>hot100</strong> </font></h4><pre><code class="lang-python">class Solution:
    def lengthOfLongestSubstring(self, s: str) -&gt; int:
        i, j = 0, 0
        ans = 0
        while(j &lt; len(s)):
            while(s[j] in s[i:j]):
                i += 1
            ans = max(ans, j-i+1)
            j+=1
        return ans
</code></pre>
<pre><code class="lang-python">class Solution:
    def lengthOfLongestSubstring(self, s: str) -&gt; int:
        lookup = collections.defaultdict(int)
        start = 0
        end = 0
        max_len = 0
        counter = 0
        ans = 0
        while end &lt; len(s):
            if lookup[s[end]] &gt; 0:
                counter += 1
            lookup[s[end]] += 1
            end += 1
            while counter &gt; 0:
                if lookup[s[start]] &gt; 1:
                    counter -= 1
                lookup[s[start]] -= 1
                start += 1
            ans = max(ans, end - start)
        return ans
</code></pre>
<ul>
<li>使用双指针，第一层while循环保证右指针小于len(s)，第二层while循环看新的字符是否出现在字符串中，如果出现就将i+1，直到不出现</li>
<li>用ans记录最大值，并且每次都j+=1</li>
</ul>
<h4 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">76. 最小覆盖子串</a></h4><pre><code class="lang-python">class Solution:
    def minWindow(self, s: str, t: str) -&gt; str:
        need=collections.defaultdict(int)
        for c in t:
            need[c] += 1
        need_cnt = len(t)
        l = 0
        ans = (0, float(&#39;inf&#39;))
        for r, c in enumerate(s):
            if need[c] &gt; 0:
                need_cnt -= 1
            need[c] -= 1
            if need_cnt == 0:  # 说明找到了子串
                while True:  # 开始收缩左边界
                    c = s[l]
                    if need[c] == 0:
                        break
                    need[c] += 1
                    l += 1
                if r - l &lt; ans[1] - ans[0]:
                    ans = (l, r)
                need[s[l]] += 1  # 强行改变左边界，找新的值
                need_cnt += 1
                l += 1
        if ans[1] &gt; len(s):
            return &#39;&#39;
        else:
            return s[ans[0]: ans[1]+1]
</code></pre>
<pre><code class="lang-python">class Solution:
    def minWindow(self, s: str, t: str) -&gt; str:
        need = collections.defaultdict(int)
        i = 0
        j = 0
        ans = &#39;&#39;
        counter = len(t)
        min_len = float(&#39;inf&#39;)
        for c in t:
            need[c]+=1
        while j &lt; len(s):
            if need[s[j]] &gt; 0:
                counter -= 1
            need[s[j]] -= 1
            j += 1
            while counter == 0:
                if min_len &gt; j - i:
                    min_len = j - i
                    ans = s[i:j]
                if need[s[i]] == 0:
                    counter += 1
                need[s[i]] += 1
                i += 1
        return ans
</code></pre>
<ul>
<li>滑动窗口的思想，共分为三步<ul>
<li>移动右边界找到包含子串中所有字符的右边界</li>
<li>移动左边界，排除掉不需要的字符</li>
<li>记录位置</li>
<li>强行移动左边界，再返回步骤1</li>
</ul>
</li>
</ul>
<p><strong><a href="https://leetcode-cn.com/problems/longest-substring-with-at-most-two-distinct-characters/" target="_blank" rel="noopener">159. 至多包含两个不同字符的最长子串</a></strong></p>
<pre><code class="lang-python">class Solution:
    def lengthOfLongestSubstringTwoDistinct(self, s: str) -&gt; int:
        from collections import defaultdict
        lookup = defaultdict(int)
        start = 0
        end = 0
        max_len = 0
        counter = 0
        while end &lt; len(s):
            if lookup[s[end]] == 0:
                counter += 1
            lookup[s[end]] += 1
            end +=1
            while counter &gt; 2:
                if lookup[s[start]] == 1:
                    counter -= 1
                lookup[s[start]] -= 1
                start += 1
            max_len = max(max_len, end - start)
        return max_len

作者：powcai
链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/hua-dong-chuang-kou-by-powcai/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<p><strong><a href="https://leetcode-cn.com/problems/longest-substring-with-at-most-k-distinct-characters/" target="_blank" rel="noopener">340. 至多包含 K 个不同字符的最长子串</a></strong></p>
<pre><code class="lang-python">class Solution:
    def lengthOfLongestSubstringKDistinct(self, s: str, k: int) -&gt; int:
        from collections import defaultdict
        lookup = defaultdict(int)
        start = 0
        end = 0
        max_len = 0
        counter = 0
        while end &lt; len(s):
            if lookup[s[end]] == 0:
                counter += 1
            lookup[s[end]] += 1
            end += 1
            while counter &gt; k:
                if lookup[s[start]] == 1:
                    counter -= 1
                lookup[s[start]] -= 1
                start += 1
            max_len = max(max_len, end - start)
        return max_len

作者：powcai
链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/hua-dong-chuang-kou-by-powcai/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<h4 id="20-有效的括号hot100"><a href="#20-有效的括号hot100" class="headerlink" title="20. 有效的括号hot100 "></a><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20. 有效的括号<font color="red"><strong>hot100</strong> </font></a></h4><pre><code class="lang-python">class Solution:
    def isValid(self, s: str) -&gt; bool:
        stack = []
        mapping = {&quot;)&quot;:&quot;(&quot;,&quot;}&quot;:&quot;{&quot;,&quot;]&quot;:&quot;[&quot;}
        for char in s:
            if char in mapping:
                top_element = stack.pop() if stack else &#39;#&#39;
                if mapping[char]!=top_element:
                    return False
            else:
                stack.append(char)
        if not stack:
            return True
        else:
            return False
</code></pre>
<h4 id="5-最长回文子串hot100"><a href="#5-最长回文子串hot100" class="headerlink" title="5. 最长回文子串hot100 "></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a><font color="red"><strong>hot100</strong> </font></h4><pre><code class="lang-python">class Solution:
    def longestPalindrome(self, s: str) -&gt; str:
        size = len(s)
        max_len = 0
        start = 0
        if size &lt; 2:
            return s
        dp = [[False for _ in range(size)] for _ in range(size)]
        for i in range(size):
            dp[i][i] = True  # 中间元素都是回文
        for j in range(1,size):
            for i in range(0, j):
                if s[i] == s[j]:
                    if j - i &lt; 3:
                        dp[i][j] = True
                    else:
                        dp[i][j] = dp[i+1][j-1]
                else:
                    dp[i][j] = False
                if dp[i][j]:
                    curlen = j-i+1
                    if curlen &gt; max_len:
                        max_len = curlen
                        start = i
        return s[start:start+max_len]
</code></pre>
<pre><code class="lang-python">class Solution:
    def longestPalindrome(self, s: str) -&gt; str:
        # s = &quot;bb&quot;
        size = len(s)
        max_len = 1
        start = 0
        if size &lt; 2:
            return s
        dp = [[False for _ in range(size)] for _ in range(size)]
        for i in range(size):
            dp[i][i] = True  # 中间元素都是回文

        for i in range(size-1, -1, -1):
            for j in range(i, size):
                # print(i)
                # print(j)
                if s[i] == s[j]:
                    if j - i &lt; 3:
                        dp[i][j] = True
                    else:
                        dp[i][j] = dp[i+1][j-1]
                else:
                    dp[i][j] = False
                if dp[i][j]:
                    curlen = j-i+1
                    if curlen &gt; max_len:
                        max_len = curlen
                        start = i
        return s[start:start+max_len]
</code></pre>
<p>注意</p>
<ul>
<li><p>使用动态规划时想象成填表，本题的关键点在于状态的设计与状态之间的转换，如果一个字符串是长度大于2的回文字符串，那么将其两边的元素去掉，仍为回文字符串。</p>
</li>
<li><p>每次均需判断当前的长度与最大长度的大小关系</p>
</li>
<li><p>第二种解法是看到隔壁评论区，因为这道题dp[i] [j]  = dp[i+1] [j-1] 所以选择i从大到小，j从小到大</p>
</li>
<li><blockquote>
<p>这个题解太棒了，很多时候不知道DP的ij怎么写，最后那幅图一目了然，如果是斜向下就是背包问题，取个len长度从2到n-1，i从0到n，j=n-len+1，如果是直线的话就取i从大到小，j从小到大，还有一个简便的方法就是看dp状态转移公式右边是i+n 还是i-n，如果i+n 那么表示下一个状态要用到上一个状态i较大的数，则i需要从大到小，如果i-n那么表示下一个状态用到上个状态较小的数，i 就可以从小到大，这个方法还适用于j。—<a href="https://leetcode-cn.com/u/dabien1/" target="_blank" rel="noopener">里扣王</a></p>
</blockquote>
</li>
<li><p>且还有个优化的点是j在本题中是一定大于i的所以j的遍历范围是从i到size</p>
</li>
</ul>
<h4 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">516. 最长回文子序列</a></h4><pre><code class="lang-python">class Solution:
    def longestPalindromeSubseq(self, s: str) -&gt; int:
        len_s = len(s)
        dp = [[0] * len_s for _ in range(len_s)]
        # base case 每个字符可以是一个回文串
        for i in range(len_s):
            dp[i][i]=1
        for i in range(len_s-1,-1,-1):
            for j in range(i+1,len_s):
                #长度加2
                if s[i]==s[j]:
                    dp[i][j] = dp[i+1][j-1]+2
                else:
                    dp[i][j]=max(dp[i+1][j],dp[i][j-1])
        return dp[0][-1]
</code></pre>
<ul>
<li>同上一题因为这道题dp[i] [j]  = dp[i+1] [j-1] 所以选择i从大到小，j从小到大</li>
<li>注意定义状态是dp[i] [j]表示的是从i到j最长回文子串的长度</li>
</ul>
<h4 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a><a href="https://leetcode-cn.com/problems/palindromic-substrings/" target="_blank" rel="noopener">647. 回文子串</a></h4><pre><code class="lang-python">class Solution:
    def countSubstrings(self, s: str) -&gt; int:
        size = len(s)
        dp = [[False for _ in range(size)] for _ in range(size)]
        for i in range(size):
            dp[i][i] = True
        ans = 0
        for i in range(size, -1, -1):
            for j in range(i, size):
                if s[i] == s[j] and ( j - i &lt; 2 or dp[i+1][j-1]):
                    dp[i][j] = True
                    ans += 1
        return ans
</code></pre>
<ul>
<li>动态规划的思想，dp[i] [j] 是否为True依赖于dp[i+1] [j-1]是否为True，且如果j - i &lt; 2代表两个字符紧挨着，则说明肯定是一个回文子串，需要ans+=1</li>
<li><p>dp是二维的数组，记录着s[i] 到s[j]是否是一个回文子串</p>
</li>
<li><p>且因为这道题dp[i] [j]  = dp[i+1] [j-1] 所以选择i从大到小，j从小到大</p>
</li>
</ul>
<pre><code class="lang-python">class Solution:
    def countSubstrings(self, s: str) -&gt; int:
        ans = 0
        for center in range(0, 2*len(s)+1):
            left = center // 2
            right = left + center % 2
            while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:
                ans += 1
                left -=1 
                right += 1
        return ans
</code></pre>
<ul>
<li>中心扩散法 <a href="https://leetcode-cn.com/problems/palindromic-substrings/solution/liang-dao-hui-wen-zi-chuan-de-jie-fa-xiang-jie-zho/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/palindromic-substrings/solution/liang-dao-hui-wen-zi-chuan-de-jie-fa-xiang-jie-zho/</a></li>
</ul>
<h4 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4. 寻找两个正序数组的中位数</a></h4><pre><code class="lang-python">class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float:
        def getkthelement(k):
            index_1 = 0
            index_2 = 0
            while True:
                if index_1 == m:
                    return nums2[index_2 + k -1]
                if index_2 == n:
                    return nums1[index_1 + k -1]
                if k == 1:
                    return min(nums1[index_1], nums2[index_2])
                new_index_1 = min(int(index_1 + k//2 -1) , m-1)
                new_index_2 = min(int(index_2 + k//2 -1) , n-1)
                pivot_1, pivot_2 = nums1[new_index_1], nums2[new_index_2]
                if pivot_1 &lt;= pivot_2:
                    k -= new_index_1 - index_1 +1
                    index_1 = new_index_1 + 1
                else:
                    k -= new_index_2 - index_2 +1
                    index_2 = new_index_2 + 1
        m = len(nums1)
        n = len(nums2)
        sum_length = m + n
        if sum_length % 2 == 1:
            return getkthelement((sum_length + 1)//2 )
        else:
            return (getkthelement(sum_length//2) + getkthelement(sum_length//2 + 1))/2
</code></pre>
<ul>
<li>根据官方的例子记住k</li>
</ul>
<h4 id="11-盛最多水的容器hot100"><a href="#11-盛最多水的容器hot100" class="headerlink" title="11. 盛最多水的容器hot100 "></a><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11. 盛最多水的容器</a><font color="red"><strong>hot100</strong> </font></h4><pre><code class="lang-python">class Solution:
    def maxArea(self, height: List[int]) -&gt; int:
        i, j = 0, len(height)-1
        max_area = 0
        while i&lt;j:
            if height[i]&lt;height[j]:
                area = (j-i)*height[i]
                i+=1
            else:
                area = (j-i)*height[j]
                j-=1
            max_area = max(area,max_area)
        return max_area
</code></pre>
<ul>
<li>关键点在于向内移动短板后的面积有可能增大，所以肯定向内移动短板</li>
<li><img src="/2021/02/01/hot100/C:/Users\14155\AppData\Roaming\Typora\typora-user-images\image-20210205162942369.png" alt="image-20210205162942369"></li>
</ul>
<h4 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a><a href="https://leetcode-cn.com/problems/product-of-array-except-self/" target="_blank" rel="noopener">238. 除自身以外数组的乘积</a></h4><p>解法1：</p>
<pre><code class="lang-python">class Solution:
    def productExceptSelf(self, nums: List[int]) -&gt; List[int]:
        length = len(nums)

        # L 和 R 分别表示左右两侧的乘积列表
        L, R, answer = [0]*length, [0]*length, [0]*length

        # L[i] 为索引 i 左侧所有元素的乘积
        # 对于索引为 &#39;0&#39; 的元素，因为左侧没有元素，所以 L[0] = 1
        L[0] = 1
        for i in range(1, length):
            L[i] = nums[i - 1] * L[i - 1]

        # R[i] 为索引 i 右侧所有元素的乘积
        # 对于索引为 &#39;length-1&#39; 的元素，因为右侧没有元素，所以 R[length-1] = 1
        R[length - 1] = 1
        for i in reversed(range(length - 1)):
            R[i] = nums[i + 1] * R[i + 1]

        # 对于索引 i，除 nums[i] 之外其余各元素的乘积就是左侧所有元素的乘积乘以右侧所有元素的乘积
        for i in range(length):
            answer[i] = L[i] * R[i]

        return answer

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/product-of-array-except-self/solution/chu-zi-shen-yi-wai-shu-zu-de-cheng-ji-by-leetcode-/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<ul>
<li>解法1是需要用O（N）的额外空间</li>
</ul>
<pre><code class="lang-python">class Solution:
    def productExceptSelf(self, nums: List[int]) -&gt; List[int]:
        length = len(nums)
        answer = [0] * length
        answer[0] = 1
        for i in range(1,len(nums)):
            answer[i] = answer[i-1] * nums[i - 1]
        R = 1
        for i in reversed(range(len(nums))):
            answer[i] = answer[i] * R
            R = R * nums[i]
        return answer
</code></pre>
<ul>
<li>解法2是直接在返回的answer上面进行操作，所以认为所需要的额外空间是O（1）</li>
</ul>
<h4 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42. 接雨水</a></h4><pre><code class="lang-python">class Solution:
    def trap(self, height: List[int]) -&gt; int:
        ans = 0
        stack = []
        for i in range(len(height)):
            while stack and height[i] &gt; height[stack[-1]]:
                cur = stack.pop()
                if not stack:
                    break
                h=min(height[i],height[stack[-1]]) - height[cur]
                ans += (i-stack[-1]-1)*h
            stack.append(i)
        return ans
</code></pre>
<pre><code class="lang-python">class Solution(object):
    def trap(self, height):
        &quot;&quot;&quot;
        :type height: List[int]
        :rtype: int
        &quot;&quot;&quot;

        if len(height) &lt;= 1:
            return 0

        max_height = 0
        max_height_index = 0

        # 找到最高点
        for i in range(len(height)):
            h = height[i]
            if h &gt; max_height:
                max_height = h
                max_height_index = i
        area = 0
        # 从左边往最高点遍历
        tmp = height[0]
        for i in range(max_height_index):
            if height[i] &gt; tmp:
                tmp = height[i]
            else:
                area = area + (tmp - height[i])

        # 从右边往最高点遍历
        tmp = height[-1]
        for i in reversed(range(max_height_index + 1, len(height))):
            if height[i] &gt; tmp:
                tmp = height[i]
            else:
                area = area + (tmp - height[i])
        return area
</code></pre>
<ul>
<li>解法一是<strong>单调栈</strong>的解法，只要当前的高度大于栈顶的高度，就出栈，i记录的是到height的第几个元素了。</li>
</ul>
<h4 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a><a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">16. 最接近的三数之和</a></h4><pre><code class="lang-python">class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -&gt; int:
        n = len(nums)
        nums.sort()
        re_min = float(&#39;inf&#39;)
        for i in range(n):
            low = i + 1
            high = n - 1
            while low &lt; high:
                three_sum = nums[i] + nums[low] + nums[high]
                x = target - three_sum
                if abs(x) &lt; re_min:
                    re_min = abs(x)
                    sum_min = three_sum
                if three_sum == target:
                    return target
                elif three_sum &lt; target:
                    low += 1
                else:
                    high -= 1
        return sum_min
</code></pre>
<ul>
<li>与三数之和是同样的思想，只不过在最开始的时候需要一个float(‘inf’)记录差异</li>
</ul>
<h4 id="401-二进制手表"><a href="#401-二进制手表" class="headerlink" title="401. 二进制手表"></a><a href="https://leetcode-cn.com/problems/binary-watch/" target="_blank" rel="noopener">401. 二进制手表</a></h4><pre><code class="lang-python">class Solution:
    def readBinaryWatch(self, num: int) -&gt; List[str]:
        bins = [str(bin(i))[2:].count(&#39;1&#39;) for i in range(60)]
        results = []
        for hour in range(12):
            for minute in range(60):
                if bins[hour]+bins[minute] == num:
                    results.append(&#39;%d:%02d&#39;%(hour,minute))
        return results
</code></pre>
<h4 id="22-括号生成hot100"><a href="#22-括号生成hot100" class="headerlink" title="22. 括号生成hot100 "></a><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">22. 括号生成<font color="red"><strong>hot100</strong> </font></a></h4><pre><code class="lang-python">class Solution:
    def generateParenthesis(self, n: int) -&gt; List[str]:
        ans = []
        cur_str = &#39;&#39;
        def dfs(cur_str, left, right):
            if left == 0 and right == 0:
                ans.append(cur_str)
                return
            if left &gt; right:
                return
            if left &gt; 0:
                dfs(cur_str+&#39;(&#39;, left - 1, right)
            if right &gt; 0:
                dfs(cur_str+&#39;)&#39;, left, right - 1)
        dfs(cur_str, n, n)
        return ans
</code></pre>
<ul>
<li>回溯的思想，就是自己调用自己，且这里的left和right指的是还有多少括号，每次拼接都是从右面进行拼接，用return进行剪枝。下图中如果左大于右，说明再往右面添加什么字符都是无效的括号，因此进行return</li>
</ul>
<p><img src="https://pic.leetcode-cn.com/7ec04f84e936e95782aba26c4663c5fe7aaf94a2a80986a97d81574467b0c513-LeetCode%20%E7%AC%AC%2022%20%E9%A2%98%EF%BC%9A%E2%80%9C%E6%8B%AC%E5%8F%B7%E7%94%9F%E5%87%BA%E2%80%9D%E9%A2%98%E8%A7%A3%E9%85%8D%E5%9B%BE.png" alt="img"></p>
<h4 id="17-电话号码的字母组合hot100"><a href="#17-电话号码的字母组合hot100" class="headerlink" title="17. 电话号码的字母组合hot100 "></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. 电话号码的字母组合<font color="red"><strong>hot100</strong> </font></a></h4><pre><code class="lang-python">class Solution:
    def letterCombinations(self, digits: str) -&gt; List[str]:
        if not digits:
            return []
        d = [&#39; &#39;, &#39;*&#39;, &#39;abc&#39;, &#39;def&#39;,&#39;ghi&#39;,&#39;jkl&#39;,&#39;mno&#39;,&#39;pqrs&#39;,&#39;tuv&#39;,&#39;wxyz&#39;]
        ans = [&#39;&#39;]
        if digits == &#39;&#39;:
            return []
        for num in digits:
            ans = [ pre+str(suf) for pre in ans for suf in d[int(num)]]
        return ans
</code></pre>
<p>注意点</p>
<ul>
<li>用列表记录手机键盘占用空间小</li>
<li>需要将num转为int</li>
<li>将pre与新的字符串进行拼接</li>
</ul>
<h4 id="46-全排列hot100"><a href="#46-全排列hot100" class="headerlink" title="46. 全排列hot100 "></a><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. 全排列<font color="red"><strong>hot100</strong> </font></a></h4><pre><code class="lang-python">class Solution:
    def permute(self, nums: List[int]) -&gt; List[List[int]]:
        ans = []
        check = [0 for _ in range(len(nums))]
        def dfs(tmp, depth, check):
            if len(nums) == depth:
                ans.append(tmp[:])
            for i in range(len(nums)):
                if not check[i]:
                    check[i] = 1
                    tmp += [nums[i]]
                    dfs(tmp, depth + 1, check)
                    check[i] = 0
                    if tmp:
                        tmp.pop()
        dfs([], 0, check)
        return ans
</code></pre>
<p>注意点</p>
<ul>
<li>使用深度优先搜索的方式进行回溯，每次回溯前要检查check的相应位置是否为0，只有为0才可以进行下一步操作，进行dfs回溯后还需要将check位置为0且将最后一位pop出去</li>
</ul>
<h4 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a><a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">47. 全排列 II</a></h4><pre><code class="lang-python">class Solution:
    def permuteUnique(self, nums: List[int]) -&gt; List[List[int]]:
        def dfs(sol,nums,used): 
            if len(sol)==len(nums):
                ans.append(sol)
                return
            for i in range(len(nums)):
                if used[i]==1:
                    continue  # 相当于剪枝
                else:
                    if i&gt;0 and nums[i]==nums[i-1] and used[i-1]==1:
                        continue
                    used[i]=1
                    dfs(sol+[nums[i]],nums,used)
                    used[i]=0
        ans = []
        used = [0 for i in range(len(nums))]
        nums = sorted(nums)
        dfs([],nums,used)
        return ans
</code></pre>
<p>注意点</p>
<ul>
<li>相比于上一题增加的代码就是去判断，nums[i-1]与nums[i]是否相等，如果相等，而且used[i-1] == 1(代表已经被用过)，那就continue下去，进行剪枝</li>
</ul>
<h4 id="19-删除链表的倒数第-N-个结点hot100"><a href="#19-删除链表的倒数第-N-个结点hot100" class="headerlink" title="19. 删除链表的倒数第 N 个结点hot100 "></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">19. 删除链表的倒数第 N 个结点<font color="red"><strong>hot100</strong> </font></a></h4><pre><code class="lang-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode:
        dummy = ListNode(0, head)
        first = head
        second = dummy
        for i in range(n):
            first = first.next
        while first:
            first = first.next
            second = second.next
        second.next = second.next.next
        return dummy.next
</code></pre>
<p>注意点</p>
<ul>
<li>用两个指针代表快慢指针向后走，且需要注意的是前三行 dummy是指向head的值为0的节点，first指向head，second指向dummy</li>
</ul>
<h4 id="39-组合总和hot100"><a href="#39-组合总和hot100" class="headerlink" title="39. 组合总和hot100 "></a><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">39. 组合总和<font color="red"><strong>hot100</strong> </font></a></h4><pre><code class="lang-python">class Solution:
    def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]:
        candidates.sort()
        n = len(candidates)
        ans = []
        def helper(i, tmp_sum, tmp):
            if tmp_sum&gt; target or i == n:
                return 
            if tmp_sum == target:
                ans.append(tmp)
                return
            helper(i, tmp_sum + candidates[i], tmp + [candidates[i]])
            helper(i+1, tmp_sum, tmp)
        helper(0, 0, [])
        return ans
</code></pre>
<p>注意</p>
<ul>
<li>本题使用回溯法，在helper中分出来两种情况，第一种是将candidates[i]无脑加到tmp_sum中，且在tmp后面排上[ candidates[i] ] 这种情况i不会+1</li>
<li>第二种情况是不管当前这种情况，将i+1 看下一个数</li>
<li>在进行操作之前需要将列表进行排序</li>
<li>return方法进行及时剪枝</li>
</ul>
<h4 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">40. 组合总和 II</a></h4><pre><code class="lang-python">class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -&gt; List[List[int]]:
        def dfs(start, path, residue):
            if residue == 0:
                ans.append(path[:])
                return
            for index in range(start, size):
                if candidates[index] &gt; residue:
                    return  # 在这里用break其实也是可以的
                if index &gt; start and candidates[index] == candidates[index - 1]:
                    continue
                path.append(candidates[index])
                dfs(index + 1, path, residue - candidates[index])
                path.pop()
        size = len(candidates)
        if size == 0:
            return []
        candidates.sort()
        ans = []
        dfs(0, [], target)
        return ans
</code></pre>
<ul>
<li><p>注意这里用break其实也是可以的，且注意break，return，continue的区别是 return直接返回，该函数就不再继续执行了，break是跳出当前循环，到“外层代码”继续执行，continue只是结束本次循环，并不会结束当前循环</p>
</li>
<li><p>第二点需要注意的是需要在第三个if中写好index &gt; start， 因为这样可以将[1,1,6] 这种情况加上，</p>
</li>
<li><blockquote>
<pre><code>Allen的评论：
解释语句: if cur &gt; begin and candidates[cur-1] == candidates[cur] 是如何避免重复的
这个避免重复当思想是在是太重要了。
这个方法最重要的作用是，可以让同一层级，不出现相同的元素。即
                  1
                 / \
                2   2  这种情况不会发生 但是却允许了不同层级之间的重复即：
               /     \
              5       5
                例2
                  1
                 /
                2      这种情况确是允许的
               /
              2  

为何会有这种神奇的效果呢？
首先 cur-1 == cur 是用于判定当前元素是否和之前元素相同的语句。这个语句就能砍掉例1。
可是问题来了，如果把所有当前与之前一个元素相同的都砍掉，那么例二的情况也会消失。 
因为当第二个2出现的时候，他就和前一个2相同了。

那么如何保留例2呢？
那么就用cur &gt; begin 来避免这种情况，你发现例1中的两个2是处在同一个层级上的，
例2的两个2是处在不同层级上的。
在一个for循环中，所有被遍历到的数都是属于一个层级的。我们要让一个层级中，
必须出现且只出现一个2，那么就放过第一个出现重复的2，但不放过后面出现的2。
第一个出现的2的特点就是 cur == begin. 第二个出现的2 特点是cur &gt; begin.
</code></pre></blockquote>
</li>
</ul>
<h4 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a><a href="https://leetcode-cn.com/problems/combination-sum-iii/" target="_blank" rel="noopener">216. 组合总和 III</a></h4><pre><code class="lang-python">class Solution:
    def combinationSum3(self, k: int, n: int) -&gt; List[List[int]]:
        ans = []
        def dfs(step, target, track):
            if target &lt; 0:
                return
            if len(track) == k and target == 0:
                ans.append(track[:])
                return
            for i in range(step, 10):
                track.append(i)
                dfs(i + 1, target - i, track)
                track.pop()
        dfs(1,n,[])
        return ans
</code></pre>
<h4 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a href="https://leetcode-cn.com/problems/combinations/" target="_blank" rel="noopener">77. 组合</a></h4><pre><code class="lang-python">class Solution:
    def combine(self, n: int, k: int) -&gt; List[List[int]]:
        def dfs(tmp, t):
            if len(tmp) == k:
                ans.append(tmp)
                return
            for i in range(t+1, n+1):
                dfs(tmp+[i], i)
        ans = []
        dfs([], 0)
        return ans
</code></pre>
<h4 id="1003-检查替换后的词是否有效"><a href="#1003-检查替换后的词是否有效" class="headerlink" title="1003. 检查替换后的词是否有效"></a><a href="https://leetcode-cn.com/problems/check-if-word-is-valid-after-substitutions/" target="_blank" rel="noopener">1003. 检查替换后的词是否有效</a></h4><pre><code class="lang-python">class Solution:
    def isValid(self, s: str) -&gt; bool:
        while (&#39;abc&#39; in s):
            s=s.replace(&#39;abc&#39;,&#39;&#39;)
        return len(s)==0
</code></pre>
<p>感觉真正出题的时候不能出这种类型的，且评论区和解题区没发现正儿八经的题解，就先记录此题</p>
<h4 id="21-合并两个有序链表hot100"><a href="#21-合并两个有序链表hot100" class="headerlink" title="21. 合并两个有序链表hot100 "></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. 合并两个有序链表<font color="red"><strong>hot100</strong> </font></a></h4><pre><code class="lang-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode:
        res = ListNode(None)
        node = res
        while l1 and l2:
            if l1.val&lt;l2.val:
                node.next,l1 = l1,l1.next
            else:
                node.next,l2 = l2,l2.next
            node = node.next
        if l1:
            node.next = l1
        else:
            node.next = l2
        return res.next
</code></pre>
<h4 id="263-丑数"><a href="#263-丑数" class="headerlink" title="263. 丑数"></a><a href="https://leetcode-cn.com/problems/ugly-number/" target="_blank" rel="noopener">263. 丑数</a></h4><pre><code class="lang-python">class Solution:
    def isUgly(self, num: int) -&gt; bool:
        if num==0:return False
        if num ==1:return True
        if num%2==0:return self.isUgly(num//2)
        if num%3==0:return self.isUgly(num//3)
        if num%5==0:return self.isUgly(num//5)
        return False
</code></pre>
<h4 id="264-丑数-II"><a href="#264-丑数-II" class="headerlink" title="264. 丑数 II"></a><a href="https://leetcode-cn.com/problems/ugly-number-ii/" target="_blank" rel="noopener">264. 丑数 II</a></h4><pre><code class="lang-python">class Solution:
    def nthUglyNumber(self, n: int) -&gt; int:
        dp, a, b, c = [1] * n, 0, 0, 0
        for i in range(1, n):
            n2, n3, n5 = dp[a] * 2, dp[b] * 3, dp[c] * 5
            dp[i] = min(n2, n3, n5)
            if dp[i] == n2: a += 1
            if dp[i] == n3: b += 1
            if dp[i] == n5: c += 1
        return dp[-1]

# 作者：jyd
# 链接：https://leetcode-cn.com/problems/chou-shu-lcof/solution/mian-shi-ti-49-chou-shu-dong-tai-gui-hua-qing-xi-t/
# 来源：力扣（LeetCode）
# 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<ul>
<li>丑数Ⅱ实际上相当于合并3个有序列表，a,b,c+=1分别相当于指针向右移动</li>
</ul>
<h4 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23. 合并K个升序链表"></a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">23. 合并K个升序链表</a></h4><pre><code class="lang-python">class Solution(object):
    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:
        if not lists:
            return
        n = len(lists)
        return self.merge(lists, 0, n-1)
    def merge(self, lists, left, right):
        if left == right:
            return lists[left]
        mid = left + (right - left)//2
        l1 = self.merge(lists, left, mid)
        l2 = self.merge(lists, mid+1, right)
        return self.merge_two_lists(l1, l2)
    def merge_two_lists(self, l1, l2):
        if not (l1 and l2):
            return l1 if l1 else l2
        if l1.val&lt;l2.val:
            l1.next = self.merge_two_lists(l1.next, l2)
            return l1
        else:
            l2.next = self.merge_two_lists(l2.next, l1)
            return l2
</code></pre>
<h4 id="31-下一个排列hot100"><a href="#31-下一个排列hot100" class="headerlink" title="31. 下一个排列hot100 "></a><a href="https://leetcode-cn.com/problems/next-permutation/" target="_blank" rel="noopener">31. 下一个排列<font color="red"><strong>hot100</strong> </font></a></h4><pre><code class="lang-python">class Solution:
    def nextPermutation(self, nums: List[int]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
        n = len(nums)
        if n &lt; 2:
            return nums
        i = n-1
        while i &gt; 0 and nums[i-1] &gt;= nums[i]:
            i -= 1
        if i == 0 :
            return nums.reverse()
        else:
            j = n-1
            while j &gt; i-1 and nums[j] &lt;= nums[i-1]:
                j -= 1
            nums[i-1], nums[j] = nums[j], nums[i-1]
            re = nums[i:]
            re = sorted(re)
            tmp = len(re)
            for k in range(len(re)): 
                nums[n+k-tmp] = re[k]
            return nums
</code></pre>
<ul>
<li>这种方法并没有使用常数的额外空间，只是记录一下</li>
</ul>
<pre><code class="lang-python">class Solution:
    def nextPermutation(self, nums: List[int]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
        n = len(nums)
        if n &lt; 2:
            return nums
        i = n-1
        while i &gt; 0 and nums[i-1] &gt;= nums[i]:
            i -= 1
        if i == 0 :
            return nums.reverse()
        else:
            j = n-1
            while j &gt; i-1 and nums[j] &lt;= nums[i-1]:
                j -= 1
            nums[i-1], nums[j] = nums[j], nums[i-1]  # 交换那两个目标数后，需要将后面的降序改为升序
            for k in range((n-i)//2):
                nums[i+k], nums[n-1-k] = nums[n-1-k], nums[i+k]
            return nums
</code></pre>
<ul>
<li>区别于第一种方法是k从0到(n-i)//2两两交换</li>
</ul>
<h4 id="60-排列序列"><a href="#60-排列序列" class="headerlink" title="60. 排列序列"></a><a href="https://leetcode-cn.com/problems/permutation-sequence/" target="_blank" rel="noopener">60. 排列序列</a></h4><pre><code class="lang-python">class Solution:
    def getPermutation(self, n: int, k: int) -&gt; str:
        def dfs(n, k, index, path):
            if index == n:
                return
            cnt = factorial[n - 1 - index]
            for i in range(1, n + 1):
                if used[i]:
                    continue
                if cnt &lt; k:
                    k -= cnt
                    continue
                path.append(i)
                used[i] = True
                dfs(n, k, index + 1, path)
                # 注意：这里要加 return，后面的数没有必要遍历去尝试了
                return
        if n == 0:
            return &quot;&quot;  # 这里是特殊情况，当n==0的时候，说明啥都不应该返回，所以返回的是空字符串
        used = [False for _ in range(n + 1)]
        path = []
        factorial = [1 for _ in range(n + 1)]
        for i in range(2, n + 1):
            factorial[i] = factorial[i - 1] * i  # 在这里记录好n层阶乘的数字大小
        dfs(n, k, 0, path)
        return &#39;&#39;.join([str(num) for num in path])

# 作者：liweiwei1419
# 链接：https://leetcode-cn.com/problems/permutation-sequence/solution/hui-su-jian-zhi-python-dai-ma-java-dai-ma-by-liwei/
# 来源：力扣（LeetCode）
# 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<ul>
<li>本题需要多次复习，暂时记录</li>
</ul>
<h4 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">32. 最长有效括号</a></h4><p>方法一：使用栈对左括号以及右括号进行存储，将所有能匹配的索引存至ans中，再对ans进行排序，如果后一个数一直比前一个数大1，说明是连续的有效括号，再依次增大i 和 j 得到最大值</p>
<pre><code class="lang-python">class Solution:
    def longestValidParentheses(self, s: str) -&gt; int:
        if not s :
            return 0
        ans = []
        stack = []
        for i in range(len(s)):
            if stack and s[i] == &#39;)&#39;:
                ans.append(stack.pop())
                ans.append(i)
            if s[i]==&#39;(&#39;:
                stack.append(i)
        ans.sort()
        i = 0
        target = 0
        while i &lt; len(ans):
            j = i
            while j &lt; len(ans)-1 and ans[j+1] == ans[j] + 1:
                j += 1
            target = max(target, j - i + 1)
            i += 1
        return target
</code></pre>
<p>方法二：</p>
<pre><code class="lang-python">class Solution:
    def longestValidParentheses(self, s):
        length = len(s)
        if length == 0:
            return 0
        dp = [0] * length
        for i in range(1,length):
                #当遇到右括号时，尝试向前匹配左括号
            if s[i] == &#39;)&#39;:
                pre = i - dp[i-1] -1;
                #如果是左括号，则更新匹配长度
                if pre&gt;=0 and s[pre] == &#39;(&#39;:
                    dp[i] = dp[i-1] + 2
                    #处理独立的括号对的情形 类似()()、()(())
                    if pre&gt;0:
                        dp[i] += dp[pre-1]
        return max(dp)
    #出自评论区 gyx2110
</code></pre>
<ul>
<li>动态规划的思路，dp这个列表记录着以s[i] 结尾的字符串最长有效括号长度</li>
<li>每次遇到右括号都尝试匹配前面的左括号</li>
<li>如果前面的是左括号，并且pre&gt;=0说明可以构成新增加的有效括号</li>
<li>再看特殊情况，如果除了这对新增加的有效括号，其前面还有匹配好的括号，令dp[i] += dp[pre-1] 得到更新后的dp值</li>
</ul>
<h4 id="33-搜索旋转排序数组hot100"><a href="#33-搜索旋转排序数组hot100" class="headerlink" title="33. 搜索旋转排序数组hot100 "></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组<font color="red"><strong>hot100</strong> </font></a></h4><pre><code class="lang-python">class Solution:
    def search(self, nums: List[int], target: int) -&gt; int:
        if nums==[]:
            return -1
        l=0
        r=len(nums)-1
        while l&lt;r:
            mid=l+(r-l)//2
            if nums[mid]&lt;nums[r]:  # 说明右面是有序的，左面有可能是无序的
                if nums[mid]&lt;target&lt;=nums[r]:  # 在右半部分找这个数
                    l=mid+1  # 改变l的值
                else:  # 说明 target在左半部分
                    r=mid
            else:  # 说明左面是有序的
                if nums[l]&lt;=target&lt;=nums[mid]:  # 
                    r=mid  # 改变r的值
                else:
                    l=mid+1
        if nums[l]==target:
            return l
        else:
            return -1
</code></pre>
<h4 id="81-搜索旋转排序数组-II"><a href="#81-搜索旋转排序数组-II" class="headerlink" title="81. 搜索旋转排序数组 II"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">81. 搜索旋转排序数组 II</a></h4><pre><code class="lang-python">class Solution:
    def search(self, nums: List[int], target: int) -&gt; bool:
        if nums==[]:
            return -1
        l=0
        r=len(nums)-1
        while l&lt;r:
            mid=l+(r-l)//2
            if nums[mid] == target:
                return True

            if nums[mid] == nums[l]:  # l和mid重复，l加一
                l += 1
            elif nums[mid] == nums[r]:  # mid和r重复，r减一
                r -= 1
            elif nums[mid] &lt; nums[r]:  # 说明右面是有序的，左面有可能是无序的
                if nums[mid]&lt;target&lt;=nums[r]:  # 在右半部分找这个数
                    l=mid+1  # 改变l的值
                else:  # 说明 target在左半部分
                    r=mid
            elif nums[mid] &gt; nums[r]:  # 说明左面是有序的
                if nums[l]&lt;=target&lt;=nums[mid]:  # 
                    r=mid  # 改变r的值
                else:
                    l=mid+1
        if nums[l]==target:
            return True
        else:
            return False
</code></pre>
<h4 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">153. 寻找旋转排序数组中的最小值</a></h4><pre><code class="lang-python">class Solution:
    def findMin(self, nums: List[int]) -&gt; int:
        left = 0
        right = len(nums)-1
        while left&lt;right:
            mid = (left+right)//2
            if nums[mid]&gt;nums[right]:
                left = mid+1
            elif nums[mid]&lt;nums[right]:
                right = mid
        return nums[left]
</code></pre>
<h4 id="34-在排序数组中查找元素的第一个和最后一个位置hot100"><a href="#34-在排序数组中查找元素的第一个和最后一个位置hot100" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置hot100 "></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. 在排序数组中查找元素的第一个和最后一个位置<font color="red"><strong>hot100</strong> </font></a></h4><pre><code class="lang-python">class Solution:
    def searchRange(self, nums: List[int], target: int) -&gt; List[int]:
        return [self.left_bound(nums,target),self.right_bound(nums,target)]
    def right_bound(self,nums,target):
        if len(nums) == 0:
            return -1
        left,right= 0,len(nums)-1
        while left &lt;= right:
            mid =(left+right)//2
            if nums[mid] == target:
                left = mid + 1
            elif nums[mid] &lt; target:
                left = mid + 1
            elif nums[mid] &gt; target:
                right = mid -1
        if right &gt;= 0 and nums[right] == target:return right
        else: return -1
    def left_bound(self,nums,target):
        if len(nums) == 0:
            return -1
        left, right = 0, len(nums) - 1
        while left &lt;= right:
            mid = (left + right+1)//2
            if nums[mid] == target:
                right = mid - 1
            elif nums[mid] &lt; target:
                left = mid + 1
            elif nums[mid] &gt; target:
                right = mid - 1
        if left &lt;= len(nums)-1 and nums[left] == target: return left
        else: return -1
</code></pre>
<ul>
<li>用二分法先找其左边界，再找其右边界</li>
</ul>
<h4 id="278-第一个错误的版本"><a href="#278-第一个错误的版本" class="headerlink" title="278. 第一个错误的版本"></a><a href="https://leetcode-cn.com/problems/first-bad-version/" target="_blank" rel="noopener">278. 第一个错误的版本</a></h4><pre><code class="lang-python"># The isBadVersion API is already defined for you.
# @param version, an integer
# @return a bool
# def isBadVersion(version):

class Solution:
    def firstBadVersion(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: int
        &quot;&quot;&quot;
        high = n
        low = 1
        while low&lt;high:
            mid = (low+high)//2
            if isBadVersion(mid):
                high = mid
            else:
                low = mid+1
        return low
</code></pre>
<h4 id="48-旋转图像hot100"><a href="#48-旋转图像hot100" class="headerlink" title="48. 旋转图像hot100 "></a><a href="https://leetcode-cn.com/problems/rotate-image/" target="_blank" rel="noopener">48. 旋转图像<font color="red"><strong>hot100</strong> </font></a></h4><pre><code class="lang-python">class Solution:
    def rotate(self, matrix: List[List[int]]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify matrix in-place instead.
        &quot;&quot;&quot;
        # 先水平翻转，再沿着主对角线翻转
        n = len(matrix)
        for i in range(n//2):
            for j in range(n):
                matrix[i][j], matrix[n-i-1][j] = matrix[n-i-1][j], matrix[i][j]
        print(matrix)
        for i in range(n):
            for j in range(i):
                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
        return matrix
</code></pre>
<ul>
<li>先水平翻转，再沿着“左上到右下”的对角线翻转</li>
</ul>
<h4 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a><a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">242. 有效的字母异位词</a></h4><pre><code class="lang-python">class Solution:
    def isAnagram(self, s: str, t: str) -&gt; bool:
        return sorted(s)==sorted(t)
</code></pre>
<ul>
<li>使用内置函数进行排序</li>
</ul>
<pre><code class="lang-python">class Solution:
    def isAnagram(self, s: str, t: str) -&gt; bool:
        if len(s) != len(t): return False
        counts = [0] * 26
        for i in range(len(s)):
            counts[ord(s[i]) - ord(&quot;a&quot;)] += 1
            counts[ord(t[i]) - ord(&quot;a&quot;)] -= 1
        for i in counts:
            if i != 0:
                return False
        return True
</code></pre>
<ul>
<li>使用列表对s和t的字符进行计数的记录，最后看看列表中每一位是否为0即可</li>
</ul>
<h4 id="49-字母异位词分组hot100"><a href="#49-字母异位词分组hot100" class="headerlink" title="49. 字母异位词分组hot100 "></a><a href="https://leetcode-cn.com/problems/group-anagrams/" target="_blank" rel="noopener">49. 字母异位词分组<font color="red"><strong>hot100</strong> </font></a></h4><pre><code class="lang-python">class Solution:
    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:
        dic = {}
        for single_str in strs:
            key = &#39;&#39;.join(sorted(single_str))
            if key in dic.keys():
                dic[key].append(single_str)
            else:
                dic[key] = [single_str]
        return list(dic.values())
</code></pre>
<pre><code class="lang-python">class Solution:
    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:
        mp = collections.defaultdict(list)
        for st in strs:
            counts = [0] * 26
            for ch in st:
                counts[ord(ch) - ord(&quot;a&quot;)] += 1
            # 需要将 list 转换成 tuple 才能进行哈希
            mp[tuple(counts)].append(st)
        return list(mp.values())

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/group-anagrams/solution/zi-mu-yi-wei-ci-fen-zu-by-leetcode-solut-gyoc/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<p>两种方法的不同点在于第一种方法的键是排序后的字符串，第二种方法的键是字母个数组成的元组，注意这里不能直接用列表当作键，所以需要转换为元组。</p>
<h4 id="53-最大子序和hot100"><a href="#53-最大子序和hot100" class="headerlink" title="53. 最大子序和hot100 "></a><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和<font color="red"><strong>hot100</strong> </font></a></h4><pre><code class="lang-python">class Solution:
    def maxSubArray(self, nums: List[int]) -&gt; int:
        max_f = nums[0]
        pre_f = nums[0]
        for i in range(1,len(nums)):
            pre_f = max(nums[i]+pre_f,nums[i])  # 该行的意思是看这个数加上去是否有用，有用就加上去，没用就算了
            max_f = max(pre_f,max_f)  # 将刚才计算的pre_f 和 max作比较，取最大的
        return max_f
</code></pre>
<h4 id="697-数组的度"><a href="#697-数组的度" class="headerlink" title="697. 数组的度"></a><a href="https://leetcode-cn.com/problems/degree-of-an-array/" target="_blank" rel="noopener">697. 数组的度</a></h4><pre><code class="lang-python">class Solution:
    def findShortestSubArray(self, nums: List[int]) -&gt; int:
        left , right , count = {},{},{}
        for i, x in enumerate(nums):
            if x not in left:
                left[x] = i
            right[x] = i
            count[x] = count.get(x,0)+1
        target = len(nums)
        degree = max(count.values())
        for x in count:
            if count[x] == degree:
                target = min(target,right[x]-left[x]+1)
        return target
</code></pre>
<p>题目的目的就是先求出来众数，然后再在数组中找到众数的左右边界距离，且如果有多个众数，就取挨的近的众数</p>
<h4 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a><a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">152. 乘积最大子数组</a></h4><pre><code class="lang-python">class Solution:
    def maxProduct(self, nums: List[int]) -&gt; int:
        if not nums:
            return
        pre_max, pre_min, ans = nums[0], nums[0], nums[0]
        for num in nums[1:]:
            cur_max = max(pre_max*num, pre_min*num, num)
            cur_min = min(pre_max*num, pre_min*num, num)
            ans = max(ans, cur_max)
            pre_max = cur_max
            pre_min = cur_min
        return ans
</code></pre>
<pre><code class="lang-python">class Solution:
    def maxProduct(self, nums: List[int]) -&gt; int:
        A = nums
        B = nums[::-1]
        for i in range(1,len(nums)):
            A[i] *= A[i-1] or 1
            B[i] *= B[i-1] or 1
        return max(max(A),max(B))
</code></pre>
<p>第一种方法比较易懂，随时记录最大值和最小值到最后给出ans</p>
<p>第二种方法是<strong>神仙写法</strong>需要用or记录A[i] , 在python里 -1 or 1 = -1; 1 or 1 = 1; 0 or 1 = 1 通过这种方式避开数组中有0的情况，此外肯定是从数组的开头到某一个数字</p>
<h4 id="376-摆动序列376-摆动序列"><a href="#376-摆动序列376-摆动序列" class="headerlink" title="376. 摆动序列376. 摆动序列"></a><a href="https://leetcode-cn.com/problems/wiggle-subsequence/" target="_blank" rel="noopener">376. 摆动序列</a><a href="https://leetcode-cn.com/problems/wiggle-subsequence/" target="_blank" rel="noopener">376. 摆动序列</a></h4><pre><code class="lang-python">class Solution:
    def wiggleMaxLength(self, nums: List[int]) -&gt; int:
        down, up = 1, 1
        for i in range(1,len(nums)):
            if nums[i] &gt; nums[i-1]:
                up = down + 1
            elif nums[i] &lt; nums[i-1]:
                down = up + 1
        if len(nums)&lt;2:
            return len(nums)
        else:
            return max(up, down)
</code></pre>
<p><img src="/2021/02/01/hot100/C:/Users\14155\AppData\Roaming\Typora\typora-user-images\image-20210226101134692.png" alt="image-20210226101134692"></p>
<h4 id="978-最长湍流子数组"><a href="#978-最长湍流子数组" class="headerlink" title="978. 最长湍流子数组"></a><a href="https://leetcode-cn.com/problems/longest-turbulent-subarray/" target="_blank" rel="noopener">978. 最长湍流子数组</a></h4><pre><code class="lang-python">class Solution:
    def maxTurbulenceSize(self, arr: List[int]) -&gt; int:
        down, up = 1, 1
        nums = arr
        ans = 0
        for i in range(1,len(nums)):
            if nums[i] &gt; nums[i-1]:
                up = down + 1
                down = 1
            elif nums[i] &lt; nums[i-1]:
                down = up + 1
                up = 1
            else:
                up, down = 1, 1
            ans = max(ans, max(up, down))
        if len(nums)&lt;2:
            return len(nums)
        else:
            return ans
</code></pre>
<ul>
<li>此题是上一题376的变形题目，在这道题里面要求必须是连续的，所以在每次+1后都需要让另一个元素置为1，且如果前一元素和后一元素相等，需要让up 和 down都置为1</li>
</ul>
<h4 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a></h4><pre><code class="lang-python">class Solution:
    def maxProfit(self, prices: List[int]) -&gt; int:
        # n_day = len(prices)  # 表示第几天
        # if n_day == 0:
        #     return 0
        # rest = 2
        # dp = [[0]*rest]*n_day
        # for i in range(n_day): 
        #     dp[i][0] = 0            
        # for i in range(n_day):
        #     if(i==0):
        #         dp[i][0] = 0
        #         dp[i][1] = -prices[i]
        #     else:
        #         dp[i][0] = max(dp[i-1][0],dp[i-1][1]+prices[i])
        #         dp[i][1] = max(dp[i-1][1],-prices[i])

        # return dp[n_day-1][0]
        if len(prices)&lt;2:
            return 0
        min_tmp = prices[0]
        ans = 0
        for i in range(1,len(prices)):
            ans = max(ans, prices[i]-min_tmp)
            min_tmp = min(min_tmp, prices[i])
        return ans
</code></pre>
<p>简单版的动态规划，用ans记录利益最大值，用min_tmp记录最小的价格</p>
<h4 id="55-跳跃游戏hot100"><a href="#55-跳跃游戏hot100" class="headerlink" title="55. 跳跃游戏hot100 "></a><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏<font color="red"><strong>hot100</strong> </font></a></h4><pre><code class="lang-python">class Solution:
    def canJump(self, nums: List[int]) -&gt; bool:
        n = len(nums)
        if n&lt;=1:
            return True
        if 0 not in nums[:n-1]:
            return True
        for i in range(n-2, -1, -1):
            if nums[i]==0:
                for j in range(i-1, -1, -1):
                    if nums[j] &gt; i-j:
                        break
                else:
                    return False
        return True
</code></pre>
<ul>
<li>思路是看数组中有没有0，如果没有0则说明肯定能到</li>
<li>如果有0，则在该位置向前找，直到找到一个nums[i] 可以使得nums[i] &gt;  i-j 这样就能保证跳过0</li>
</ul>
<h4 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a><a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">45. 跳跃游戏 II</a></h4><pre><code class="lang-python">class Solution:
    def jump(self, nums: List[int]) -&gt; int:
        n = len(nums)
        max_pos, end, step = 0, 0, 0
        for i in range(n-1):
            max_pos = max(max_pos, i+nums[i])
            if end == i:
                end = max_pos
                step+=1
        return step
</code></pre>
<h4 id="56-合并区间hot100"><a href="#56-合并区间hot100" class="headerlink" title="56. 合并区间hot100 "></a><a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">56. 合并区间<font color="red"><strong>hot100</strong> </font></a></h4><pre><code class="lang-python">class Solution:
    def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]:
        intervals.sort(key=lambda x: x[0])
        ans = []
        for i in intervals:
            if not ans or ans[-1][1] &lt; i[0]:
                ans.append(i)
            else:
                ans[-1][1] = max(ans[-1][1], i[1])
        return ans
</code></pre>
<h4 id="57-插入区间"><a href="#57-插入区间" class="headerlink" title="57. 插入区间"></a><a href="https://leetcode-cn.com/problems/insert-interval/" target="_blank" rel="noopener">57. 插入区间</a></h4><pre><code class="lang-python">class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -&gt; List[List[int]]:
        intervals.append(newInterval)
        intervals.sort(key=lambda x: x[0])
        ans = []
        for i in intervals:
            if not ans or ans[-1][1] &lt; i[0]:
                ans.append(i)
            else:
                ans[-1][1] = max(ans[-1][1], i[1])
        return ans
</code></pre>
<h4 id="495-提莫攻击"><a href="#495-提莫攻击" class="headerlink" title="495. 提莫攻击"></a><a href="https://leetcode-cn.com/problems/teemo-attacking/" target="_blank" rel="noopener">495. 提莫攻击</a></h4><pre><code class="lang-python">class Solution:
    def findPoisonedDuration(self, timeSeries: List[int], duration: int) -&gt; int:
        intervals = []
        for i in timeSeries:
            intervals.append([i, i+duration])
        print(intervals)
        intervals.sort(key=lambda x: x[0])
        ans = []
        for i in intervals:
            if not ans or ans[-1][1] &lt; i[0]:
                ans.append(i)
            else:
                ans[-1][1] = max(ans[-1][1], i[1])
        target = 0
        for i in ans:
            target+=i[1]-i[0]
        return target
</code></pre>
<h4 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a><a href="https://leetcode-cn.com/problems/partition-labels/" target="_blank" rel="noopener">763. 划分字母区间</a></h4><pre><code class="lang-python">class Solution:
    def partitionLabels(self, S: str) -&gt; List[int]:
        tmp = [[501, 0] for _ in range(26)]
        for i,ch in enumerate(S):
            if i &gt; tmp[ord(ch)-ord(&#39;a&#39;)][1]:
                tmp[ord(ch)-ord(&#39;a&#39;)][1] = i
            if i &lt; tmp[ord(ch)-ord(&#39;a&#39;)][0]:
                tmp[ord(ch)-ord(&#39;a&#39;)][0] = i
        intervals = tmp
        intervals.sort(key=lambda x: x[0])
        ans = []
        for i in intervals:
            if not ans or ans[-1][1] &lt; i[0]:
                ans.append(i)
            else:
                ans[-1][1] = max(ans[-1][1], i[1])
        target = []
        for i in ans:
            if i[0]!=501:
                target.append(i)   
        true_ans = [i[1]-i[0]+1 for i in target]
        return true_ans
</code></pre>
<p>可以沿着这个思路继续做，把所有的字母的开始位置和结束位置统计出来，然后像56题一样合并区间，最后再把合并后的区间尾-首+1 逐渐append到要返回的列表即可</p>
<p>也可以采用聪明一点的解法：</p>
<pre><code class="lang-python">class Solution:
    def partitionLabels(self, S: str) -&gt; List[int]:
        tmp = [0]*26
        for i,ch in enumerate(S):
            tmp[ord(ch)-ord(&#39;a&#39;)] = i
        ans = []
        start = end = 0
        for i ,ch in enumerate(S):
            end = max(end,tmp[ord(ch)-ord(&#39;a&#39;)])
            if i==end:
                ans.append(end-start+1)
                start = end+1
        return ans
</code></pre>
<h4 id="986-区间列表的交集"><a href="#986-区间列表的交集" class="headerlink" title="986. 区间列表的交集"></a><a href="https://leetcode-cn.com/problems/interval-list-intersections/" target="_blank" rel="noopener">986. 区间列表的交集</a></h4><pre><code class="lang-python">class Solution:
    def intervalIntersection(self, firstList: List[List[int]], secondList: List[List[int]]) -&gt; List[List[int]]:
        ans = []
        A = firstList
        B = secondList
        m, n = len(firstList), len(secondList)
        i, j = 0, 0
        while i&lt;m and j&lt;n:
            left = max(A[i][0], B[j][0])
            right = min(A[i][1], B[j][1])
            if left &lt;= right:
                ans.append([left, right])
            if A[i][1]&gt;B[j][1]:
                j+=1
            else:
                i+=1
        return ans
</code></pre>
<h4 id="62-不同路径hot100"><a href="#62-不同路径hot100" class="headerlink" title="62. 不同路径hot100 "></a><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径<font color="red"><strong>hot100</strong> </font></a></h4><pre><code class="lang-python">class Solution:
    def uniquePaths(self, m: int, n: int) -&gt; int:
        # def helper(i):
        #     tmp_ans = 1
        #     for i in range(i,0,-1):
        #         tmp_ans*=i
        #     return tmp_ans
        # total_step = m+n-2
        # down = m-1
        # right = n-1
        # return int(helper(total_step)/helper(down)/helper(right))
        dp = [[1]*n] + [[1] + [0]*(n-1) for _ in range(m-1)]
        for i in range(1, m):
            for j in range(1,n):
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
        return dp[-1][-1]
</code></pre>
<p>第一种方法为公式法，直接算C(m+n-2,m-1)第二种方法是动态规划的方法</p>
<ul>
<li>注意初始化dp数组的方法</li>
<li>dp[i] [j] = dp[i-1] [j] + dp[i] [j-1] 是状态转移方程</li>
<li>dp[i] [j] 代表机器人去往第i行第j列的方式</li>
</ul>
<h4 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a><a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">63. 不同路径 II</a></h4><pre><code class="lang-python">class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int:
        # obstacleGrid = [[0,0],[1,1],[0,0]]
        row = len(obstacleGrid)
        col = len(obstacleGrid[0])
        if obstacleGrid[row-1][col-1]==1 or obstacleGrid[0][0]==1:
            return 0
        dp = [[0 for _ in range(col)] for _ in range(row)]
        for i in range(row):
            if obstacleGrid[i][0]==0:
                dp[i][0] = 1
            if obstacleGrid[i][0]==1:
                dp[i][0] = 0
                break
        for i in range(col):
            if obstacleGrid[0][i]==0:
                dp[0][i] = 1
            if obstacleGrid[0][i]==1:
                dp[0][i] = 0
                break
        for i in range(1,row):
            for j in range(1,col):
                if obstacleGrid[i][j] == 0:
                    dp[i][j] = dp[i-1][j]+dp[i][j-1]
        #最后一列 和最后一行
        return dp[row-1][col-1]
</code></pre>
<h4 id="64-最小路径和hot100"><a href="#64-最小路径和hot100" class="headerlink" title="64. 最小路径和hot100 "></a><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">64. 最小路径和<font color="red"><strong>hot100</strong> </font></a></h4><pre><code class="lang-python">class Solution:
    def minPathSum(self, grid: List[List[int]]) -&gt; int:
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if i==j==0:
                    continue
                elif i==0:
                    grid[i][j] = grid[i][j-1] + grid[i][j]
                elif j==0:
                    grid[i][j] = grid[i-1][j] + grid[i][j]
                else:
                    grid[i][j] = min(grid[i-1][j], grid[i][j-1]) + grid[i][j]
        return grid[-1][-1]
</code></pre>
<h4 id="174-地下城游戏"><a href="#174-地下城游戏" class="headerlink" title="174. 地下城游戏"></a><a href="https://leetcode-cn.com/problems/dungeon-game/" target="_blank" rel="noopener">174. 地下城游戏</a></h4><pre><code class="lang-python">class Solution:
    def calculateMinimumHP(self, dungeon: List[List[int]]) -&gt; int:
        big = 10**9
        m = len(dungeon)
        n = len(dungeon[0])
        dp = [[big] * (n+1) for _ in range(m+1)]
        dp[m][n-1] = dp[m-1][n] = 1
        for i in range(m-1, -1, -1):
            for j in range(n-1, -1, -1):
                dp[i][j] = max(1,min(dp[i+1][j],dp[i][j+1])-dungeon[i][j])
        return dp[0][0]
</code></pre>
<h4 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a><a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">509. 斐波那契数</a></h4><pre><code class="lang-python">class Solution:
    def fib(self, n: int) -&gt; int:
        a, b = 0, 1
        for _ in range(n):
            a, b = b, a + b
        return a #% 1000000007

# 作者：jyd
# 链接：https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/solution/mian-shi-ti-10-i-fei-bo-na-qi-shu-lie-dong-tai-gui/
# 来源：力扣（LeetCode）
# 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<h4 id="70-爬楼梯hot100"><a href="#70-爬楼梯hot100" class="headerlink" title="70. 爬楼梯hot100 "></a><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯<font color="red"><strong>hot100</strong> </font></a></h4><pre><code class="lang-python">class Solution:
    def climbStairs(self, n: int) -&gt; int:
        a, b = 1, 1
        for _ in range(n):
            a, b = b, a + b
        return a % 1000000007

# 作者：jyd
# 链接：https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/solution/mian-shi-ti-10-ii-qing-wa-tiao-tai-jie-wen-ti-dong/
# 来源：力扣（LeetCode）
# 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<h4 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/" target="_blank" rel="noopener">746. 使用最小花费爬楼梯</a></h4><pre><code class="lang-python">class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -&gt; int:
        dp = [0]*len(cost)
        dp[0] = cost[0]
        dp[1] = cost[1]
        for i in range(2,len(cost)):
            dp[i] = min(dp[i-1],dp[i-2])+cost[i]
        return min(dp[-1],dp[-2])
</code></pre>
<p>同上面的动态规划的思想，从前向后遍历，第i个数取决于前两个最小值+当前台阶的体力</p>
<h4 id="1137-第-N-个泰波那契数"><a href="#1137-第-N-个泰波那契数" class="headerlink" title="1137. 第 N 个泰波那契数"></a><a href="https://leetcode-cn.com/problems/n-th-tribonacci-number/" target="_blank" rel="noopener">1137. 第 N 个泰波那契数</a></h4><pre><code class="lang-python">class Solution:
    def tribonacci(self, n: int) -&gt; int:
        a, b, c = 0, 1, 1
        for _ in range(n):
            a, b, c = b, c, a+b+c
        return a #% 1000000007
</code></pre>
<h4 id="72-编辑距离hot100"><a href="#72-编辑距离hot100" class="headerlink" title="72. 编辑距离hot100 "></a><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离<font color="red"><strong>hot100</strong> </font></a></h4><pre><code class="lang-python">class Solution:
    def minDistance(self, word1: str, word2: str) -&gt; int:
        n1 = len(word1)
        n2 = len(word2)
        dp = [[0] * (n2 + 1) for _ in range(n1 + 1)]
        # 第一行
        for j in range(1, n2 + 1):
            dp[0][j] = dp[0][j-1] + 1
        # 第一列
        for i in range(1, n1 + 1):
            dp[i][0] = dp[i-1][0] + 1
        for i in range(1, n1 + 1):
            for j in range(1, n2 + 1):
                if word1[i-1] == word2[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    dp[i][j] = min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1] ) + 1
        #print(dp)      
        return dp[-1][-1]

# 作者：powcai
# 链接：https://leetcode-cn.com/problems/edit-distance/solution/zi-di-xiang-shang-he-zi-ding-xiang-xia-by-powcai-3/
# 来源：力扣（LeetCode）
# 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<h4 id="75-颜色分类hot100"><a href="#75-颜色分类hot100" class="headerlink" title="75. 颜色分类hot100 "></a><a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">75. 颜色分类<font color="red"><strong>hot100</strong> </font></a></h4><pre><code class="lang-python">class Solution:
    def sortColors(self, nums: List[int]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
        n = len(nums)
        num_1 = 0
        num_0 = 0
        for i in nums:
            if i==0:
                num_0+=1
            if i==1:
                num_1+=1
        num_2 = n-num_1-num_0
        for i in range(num_0):
            nums[i] = 0
        for i in range(num_0,num_0+num_1):
            nums[i] = 1
        for i in range(num_0+num_1,n):
            nums[i] = 2
</code></pre>
<ul>
<li>第一种方法是计数出来0,1,2分别有多少个，然后在原数组上面进行更改</li>
</ul>
<pre><code class="lang-python">class Solution:
    def sortColors(self, nums: List[int]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
        n = len(nums)
        def swap(nums, index1, index2):
            nums[index1], nums[index2] = nums[index2], nums[index1]
        zero = 0
        two = n-1
        i = 0
        while i &lt;= two:
            if nums[i]==0:
                swap(nums, zero, i)
                zero += 1
                i+=1
            elif nums[i]==1:
                i+=1
            elif nums[i]==2:
                swap(nums, i,two)
                two-=1
</code></pre>
<p>注意点 </p>
<ul>
<li>循环条件是i&lt;two </li>
<li>当第i个数等于0的时候，第i个数与zero互换，且i+=1,zero+=1</li>
<li>当第i个数等于1的时候，跳过i+=1</li>
<li>当第i个数等于2的时候，第i个数与two互换two-=1</li>
</ul>
<h4 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">283. 移动零</a></h4><pre><code class="lang-python">class Solution:
    def moveZeroes(self, nums: List[int]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
        j = 0
        for i in range(len(nums)):
            if nums[i] != 0:
                nums[i], nums[j] = nums[j], nums[i]
                j += 1
</code></pre>
<ul>
<li>类似于快速排序的思想，如果这个元素不等于0 就将这个元素与索引为j的元素进行互换，且每次判断不等于0的时候j+=1</li>
</ul>
<h4 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a href="https://leetcode-cn.com/problems/remove-element/" target="_blank" rel="noopener">27. 移除元素</a></h4><pre><code class="lang-python">class Solution:
    def removeElement(self, nums: List[int], val: int) -&gt; int:
        j = 0
        for i in range(len(nums)):
            if nums[i]!=val:
                nums[j] = nums[i]
                j+=1
        return j
</code></pre>
<ul>
<li>正序的方法，如果第i个数不等于val值，就给nums[j] 赋值为nums[i]</li>
</ul>
<pre><code class="lang-python">class Solution:
    def removeElement(self, nums: List[int], val: int) -&gt; int:
        j = len(nums)-1
        for i in range(j,-1,-1):
            if nums[i] == val:
                nums.pop(i)
        return len(nums)
</code></pre>
<ul>
<li>倒序的方法，如果这个数等于val值，就Pop掉</li>
</ul>
<h4 id="324-摆动排序-II"><a href="#324-摆动排序-II" class="headerlink" title="324. 摆动排序 II"></a><a href="https://leetcode-cn.com/problems/wiggle-sort-ii/" target="_blank" rel="noopener">324. 摆动排序 II</a></h4><pre><code>class Solution:
    def wiggleSort(self, nums: List[int]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
        nums.sort()
        half = len(nums[::2])
        nums[::2], nums[1::2] = nums[:half][::-1], nums[half:][::-1]
</code></pre><ul>
<li>先分成两部分，较小的一半和较大的一半</li>
<li>再倒叙赋值</li>
</ul>
<h4 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a><a href="https://leetcode-cn.com/problems/permutation-in-string/" target="_blank" rel="noopener">567. 字符串的排列</a></h4><pre><code class="lang-python">class Solution:
    def checkInclusion(self, s1: str, s2: str) -&gt; bool:
        counter1 = collections.Counter(s1)
        N = len(s2)
        right = len(s1) - 1
        left = 0
        counter2 = collections.Counter(s2[0:right])
        while right &lt; N:
            counter2[s2[right]]+=1
            if counter1 == counter2:
                return True
            counter2[s2[left]] -= 1
            if counter2[s2[left]]==0:
                del counter2[s2[left]]
            left += 1
            right += 1
        return False
</code></pre>
<p><a href="https://leetcode-cn.com/problems/permutation-in-string/solution/zhu-shi-chao-xiang-xi-de-hua-dong-chuang-rc7d/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutation-in-string/solution/zhu-shi-chao-xiang-xi-de-hua-dong-chuang-rc7d/</a></p>
<p>滑动窗口的思想，注意点是当窗口右移的时候要判断其counter2[s2[left]] 是否为0，如果为0需要删掉，因为</p>
<blockquote>
<p><code>{&quot;a&quot;:0, &quot;b&quot;:1}</code> 和 <code>{&quot;b&quot;:1}</code> 是不等的。</p>
</blockquote>
<h4 id="78-子集hot100"><a href="#78-子集hot100" class="headerlink" title="78. 子集hot100 "></a><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78. 子集</a><font color="red"><strong>hot100</strong> </font></h4><pre><code class="lang-python">class Solution:
    def subsets(self, nums: List[int]) -&gt; List[List[int]]:
        ans = [[]]
        for i in range(len(nums)):
            for subans in ans[:]:
                ans.append(subans+[nums[i]])
        return ans
</code></pre>
<h4 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">209. 长度最小的子数组</a></h4><pre><code class="lang-python">class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -&gt; int:
        if target &gt; sum(nums):
            return 0
        left = 0
        right = 0
        res = len(nums)+1
        sum_lr = 0
        while right &lt; len(nums):
            while sum_lr &lt; target and right &lt; len(nums):
                sum_lr += nums[right]
                right += 1
            while sum_lr &gt;= target:
                res = min(res, right - left)
                sum_lr -= nums[left]
                left+=1
        return res
</code></pre>
<h4 id="79-单词搜索hot100"><a href="#79-单词搜索hot100" class="headerlink" title="79. 单词搜索hot100 "></a><a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">79. 单词搜索<font color="red"><strong>hot100</strong> </font></a></h4><pre><code class="lang-python">class Solution:
    def exist(self, board, word):
        &quot;&quot;&quot;
        :type board: List[List[str]]
        :type word: str
        :rtype: bool
        &quot;&quot;&quot;
        self.directs = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        m = len(board)
        if m == 0:
            return False
        n = len(board[0])
        mark = [[0 for _ in range(n)] for _ in range(m)]

        for i in range(len(board)):
            for j in range(len(board[0])):
                if board[i][j] == word[0]:
                    # 将该元素标记为已使用
                    mark[i][j] = 1
                    if self.backtrack(i, j, mark, board, word[1:]) == True:
                        return True
                    else:
                        # 回溯
                        mark[i][j] = 0
        return False


    def backtrack(self, i, j, mark, board, word):
        if len(word) == 0:
            return True

        for direct in self.directs:
            cur_i = i + direct[0]
            cur_j = j + direct[1]

            if cur_i &gt;= 0 and cur_i &lt; len(board) and cur_j &gt;= 0 and cur_j &lt; len(board[0]) and board[cur_i][cur_j] == word[0]:
                # 如果是已经使用过的元素，忽略
                if mark[cur_i][cur_j] == 1:
                    continue
                # 将该元素标记为已使用
                mark[cur_i][cur_j] = 1
                if self.backtrack(cur_i, cur_j, mark, board, word[1:]) == True:
                    return True
                else:
                    # 回溯
                    mark[cur_i][cur_j] = 0
        return False

# 作者：jalan
# 链接：https://leetcode-cn.com/problems/word-search/solution/shen-du-you-xian-sou-suo-yu-hui-su-xiang-jie-by-ja/
# 来源：力扣（LeetCode）
# 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<h4 id="94-二叉树的中序遍历hot100"><a href="#94-二叉树的中序遍历hot100" class="headerlink" title="94. 二叉树的中序遍历hot100 "></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历<font color="red"><strong>hot100</strong> </font></a></h4><pre><code class="lang-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def inorderTraversal(self, root: TreeNode) -&gt; List[int]:
        WHITE, GRAY = 0, 1
        res = []
        stack = [(WHITE, root)]
        while stack:
            color, node = stack.pop()
            if node is None: continue
            if color == WHITE:
                stack.append((WHITE, node.right))
                stack.append((GRAY, node))
                stack.append((WHITE, node.left))
            else:
                res.append(node.val)
        return res
</code></pre>
<h4 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">144. 二叉树的前序遍历</a></h4><pre><code class="lang-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def preorderTraversal(self, root: TreeNode) -&gt; List[int]:
        # def dfs(root):
        #     if not root:
        #         return
        #     res.append(root.val)
        #     dfs(root.left)
        #     dfs(root.right)
        # res = []
        # dfs(root)
        # return res
        WHITE, GRAY = 0, 1
        res = []
        stack = [(WHITE, root)]
        while stack:
            color, node = stack.pop()
            if node is None: continue
            if color == WHITE:
                stack.append((WHITE, node.right))
                stack.append((WHITE, node.left))
                stack.append((GRAY, node))
            else:
                res.append(node.val)
        return res
</code></pre>
<h4 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">145. 二叉树的后序遍历</a></h4><pre><code class="lang-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def postorderTraversal(self, root: TreeNode) -&gt; List[int]:
        WHITE, GRAY = 0, 1
        res = []
        stack = [(WHITE, root)]
        while stack:
            color, node = stack.pop()
            if node is None: continue
            if color == WHITE:
                stack.append((GRAY, node))
                stack.append((WHITE, node.right))
                stack.append((WHITE, node.left))
            else:
                res.append(node.val)
        return res
</code></pre>
<h4 id="101-对称二叉树hot100"><a href="#101-对称二叉树hot100" class="headerlink" title="101. 对称二叉树hot100 "></a><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">101. 对称二叉树<font color="red"><strong>hot100</strong> </font></a></h4><pre><code class="lang-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isSymmetric(self, root: TreeNode) -&gt; bool:
        def check(node1,node2):
            if not node1 and not node2:
                return True
            elif not node1 or not node2:
                return False
            if node1.val!=node2.val:
                return False
            return check(node1.left,node2.right) and check(node1.right,node2.left)
        return check(root,root)
</code></pre>
<h4 id="96-不同的二叉搜索树hot100"><a href="#96-不同的二叉搜索树hot100" class="headerlink" title="96. 不同的二叉搜索树hot100 "></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">96. 不同的二叉搜索树<font color="red"><strong>hot100</strong> </font></a></h4><pre><code class="lang-python">class Solution:
    def numTrees(self, n: int) -&gt; int:
        dp = [0]*(n+1)
        dp[0] = dp[1] = 1#base case是dp[0]和dp[1]都是1,意思是0个节点和1个节点都只有一种排序方法
        for i in range(2,n+1):#i从2开始一直到n
            for j in range(0,i):#j的范围需要从1开始一直到i
                dp[i] += dp[j]*dp[i-j-1]
        return dp[n]
</code></pre>
<h4 id="98-验证二叉搜索树hot100"><a href="#98-验证二叉搜索树hot100" class="headerlink" title="98. 验证二叉搜索树hot100 "></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. 验证二叉搜索树<font color="red"><strong>hot100</strong> </font></a></h4><pre><code class="lang-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isValidBST(self, root: TreeNode) -&gt; bool:
        WHITE, GRAY = 0, 1
        res = []
        stack = [(WHITE, root)]
        while stack:
            color, node = stack.pop()
            if node is None: continue
            if color == WHITE:
                stack.append((WHITE, node.right))
                stack.append((GRAY, node))
                stack.append((WHITE, node.left))
            else:
                res.append(node.val)
        for i in range(len(res)-1):
            if res[i]&gt;=res[i+1]:
                return False
        return True
</code></pre>
<h4 id="102-二叉树的层序遍历hot100"><a href="#102-二叉树的层序遍历hot100" class="headerlink" title="102. 二叉树的层序遍历hot100 "></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. 二叉树的层序遍历</a><font color="red"><strong>hot100</strong> </font></h4><pre><code class="lang-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:
        if not root:
            return []
        res,queue = [],[root]
        while queue:
            tmp = []
            for _ in range(len(queue)):
                node = queue.pop(0)
                tmp.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            res.append(tmp)
        return res
</code></pre>
<ul>
<li>注意点是需要shezhihi 一个临时的tmp作为上一层的存储器，然后该层遍历完后，再将tmp加到res中</li>
</ul>
<h4 id="104-二叉树的最大深度hot100"><a href="#104-二叉树的最大深度hot100" class="headerlink" title="104. 二叉树的最大深度hot100 "></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">104. 二叉树的最大深度<font color="red"><strong>hot100</strong> </font></a></h4><pre><code class="lang-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def maxDepth(self, root: TreeNode) -&gt; int:
        if not root:
            return 0
        self.ans = 0
        self._dfs(root,0)
        return self.ans
    def _dfs(self,node,level):
        if not node:
            return
        if self.ans&lt;level+1:
            self.ans = level+1
        self._dfs(node.left,level+1)
        self._dfs(node.right,level+1)
</code></pre>
<pre><code class="lang-python">class Solution:
    def maxDepth(self, root):
        if root is None: 
            return 0 
        else: 
            left_height = self.maxDepth(root.left) 
            right_height = self.maxDepth(root.right) 
            return max(left_height, right_height) + 1 

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/er-cha-shu-de-zui-da-shen-du-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<ul>
<li>第二种是比较巧妙的dfs写法</li>
</ul>
<h4 id="105-从前序与中序遍历序列构造二叉树hot100"><a href="#105-从前序与中序遍历序列构造二叉树hot100" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树hot100 "></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">105. 从前序与中序遍历序列构造二叉树</a><font color="red"><strong>hot100</strong> </font></h4><pre><code class="lang-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:
        if not preorder:
            return None
        root = TreeNode(preorder[0])
        i = inorder.index(root.val)
        root.left = self.buildTree(preorder[1:i+1],inorder[:i])
        root.right = self.buildTree(preorder[i+1:],inorder[i+1:])
        return root
</code></pre>
<h4 id="114-二叉树展开为链表hot100"><a href="#114-二叉树展开为链表hot100" class="headerlink" title="114. 二叉树展开为链表hot100 "></a><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">114. 二叉树展开为链表<font color="red"><strong>hot100</strong> </font></a></h4><pre><code class="lang-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def flatten(self, root: TreeNode) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify root in-place instead.
        &quot;&quot;&quot;
        WHITE, GRAY = 0, 1
        res = []
        stack = [(WHITE, root)]
        while stack:
            color, node = stack.pop()
            if node is None: continue
            if color == WHITE:
                stack.append((WHITE, node.right))
                stack.append((WHITE, node.left))
                stack.append((GRAY, node))
            else:
                res.append(node)
        for i in range(len(res)-1):
            res[i].left = None
            res[i].right = res[i+1]
</code></pre>
<font color="red">**hot100** </font>



<hr>
<h4 id="888-公平的糖果棒交换"><a href="#888-公平的糖果棒交换" class="headerlink" title="888. 公平的糖果棒交换"></a><a href="https://leetcode-cn.com/problems/fair-candy-swap/" target="_blank" rel="noopener">888. 公平的糖果棒交换</a></h4><pre><code class="lang-python">class Solution:
    def fairCandySwap(self, A: List[int], B: List[int]) -&gt; List[int]:
        Alice = sum(A)
        Bob = sum(B)
        SET_Bob = set(B)
        for i in A:
            if i - (Alice-Bob)/2 in SET_Bob:
                return [i, int(i - (Alice-Bob)/2)]
</code></pre>
<h4 id="424-替换后的最长重复字符"><a href="#424-替换后的最长重复字符" class="headerlink" title="424. 替换后的最长重复字符"></a><a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/" target="_blank" rel="noopener">424. 替换后的最长重复字符</a></h4><pre><code class="lang-python">class Solution:
    def characterReplacement(self, s: str, k: int) -&gt; int:
        &quot;&quot;&quot;
        :type s: str
        :type k: int
        :rtype: int
        &quot;&quot;&quot;
        N = len(s)
        left, right = 0, 0 # [left, right] 都包含
        counter = {}
        res = 0
        char_max  = 0
        while right &lt; N:
            counter.setdefault(s[right], 0)
            counter[s[right]] += 1
            char_max = max(char_max, counter[s[right]])
            while right - left + 1 - char_max &gt; k:
                counter[s[left]] -= 1
                left += 1
            res = max(res, right - left + 1)
            right += 1
        return res

# 作者：fuxuemingzhu
# 链接：https://leetcode-cn.com/problems/longest-repeating-character-replacement/solution/fen-xiang-zhen-cang-de-shuang-zhi-zhen-m-fdsk/
# 来源：力扣（LeetCode）
# 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<p>注意点</p>
<p>核心要点：（出自<a href="https://leetcode-cn.com/u/chi-ban-mian-xiang-he-tang/" target="_blank" rel="noopener">吃拌面想喝汤L1</a>）</p>
<p>1、map记录的是【窗口里的】字符出现的次数，是窗口里的！窗口里的！所以左窗口右移后，记得将移出去的元素个数-1</p>
<p>2、我们的目的就是让窗口尽可能扩张，有K个字符的容错机会，容错机会肯定要用给map中出现次数最多的字符才有机会让窗口扩张</p>
<p>3、就算某一刻你发现框里元素都不一样，但不要怀疑，因为它曾经辉煌过,它会一直呈现它窗口最大时候的状态</p>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 1415500736@qq.com </span>
    </div>
</article>


<p>
    <a href="javascript:void(0)" class="dashang" onclick="dashangToggle()">赏</a>
</p>


<div class="article_copyright">
    <p><span class="copy-title">文章标题:</span>leetcodehot</p>
    
    <p><span class="copy-title">本文作者:</span><a href="javascript:void(0)" title="Rock">Rock</a></p>
    <p><span class="copy-title">发布时间:</span>2021-02-01, 20:19:39</p>
    <p><span class="copy-title">最后更新:</span>2021-03-03, 18:13:04</p>
    <span class="copy-title">原始链接:</span><a class="post-url" href="/2021/02/01/hot100/" title="leetcodehot">http://rock-blog.top/2021/02/01/hot100/</a>
    <p>
        <span class="copy-title">版权声明:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target="_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
    </p>
</div>



    <div id="comments"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script type="text/javascript">
    $.getScript('/js/gitalk.js', function () {
        var gitalk = new Gitalk({
            clientID: 'e78b4c19bc08850d88df',
            clientSecret: '308b55a6d580ee7a819af0f950b3188be697ae29',
            repo: 'guobaoyo.github.io',
            owner: 'guobaoyo',
            admin: ['guobaoyo'],
            id: decodeURI(location.pathname),
            distractionFreeMode: 'true',
            language: 'zh-CN',
            perPage: parseInt('10',10)
        })
        gitalk.render('comments')
    })
</script>




    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async src="//cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<input type="hidden" id="MathJax-js" value="//cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">

    




    </div>
    <div class="copyright">
        <p class="footer-entry">©2016-2019 Rock&#39;s  blog</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full"><span class="min "></span></button>
<button class="post-toc-menu"><span class="post-toc-menu-icons"></span></button>
<div class="post-toc"><span class="post-toc-title">目录</span>
    <div class="post-toc-content">

    </div>
</div>
<a class id="rocket" href="javascript:void(0)"></a>
    </div>
</div>
<div class="acParent"></div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close" href="javascript:void(0)" onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.0.1"></script>

<script src="/js/script.js?v=1.0.1"></script>
<script>
    var img_resize = 'default';
    /*作者、标签的自动补全*/
    $(function () {
        $('.search').AutoComplete({
            'data': ['#三省吾身','#AI','#数学','#深度学习','#CV','#python','#编程','#强化学习','#技术小节','#技术小结','#go','#leetcode','#组会报告','#考研','#NLP',],
            'itemHeight': 20,
            'width': 418
        }).AutoComplete('show');
    })
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $(".post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().split('\n').length - 1, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0px;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: #fafafa;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
        .nav .hide-list.fullscreen {
            left: 492px
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #c1bfc1;
    }
    
    

    /*列表样式*/
    
    .post .pjax article .article-entry>ol, .post .pjax article .article-entry>ul, .post .pjax article>ol, .post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    .post .pjax article .article-entry li>ol, .post .pjax article .article-entry li>ul,.post .pjax article li>ol, .post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    .post .pjax article .article-entry>ol>li, .post .pjax article .article-entry>ul>li,.post .pjax article>ol>li, .post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    .post .pjax article .article-entry li>ol>li, .post .pjax article .article-entry li>ul>li,.post .pjax article li>ol>li, .post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    
    .nav-right:before {
        content: ' ';
        display: block;
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 0.5;
        background: url("https://i.loli.net/2019/07/22/5d3521411f3f169375.png");
        background-repeat: no-repeat;
        background-position: 50% 0;
        -ms-background-size: cover;
        -o-background-size: cover;
        -moz-background-size: cover;
        -webkit-background-size: cover;
        background-size: cover;
    }
    

    
</style>







</html>
